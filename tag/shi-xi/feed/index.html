<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Linux迷+Python粉 - 实习</title><link>https://pythonwood.github.io/</link><description>人生苦短，我用Python</description><lastBuildDate>Thu, 30 Nov 2017 22:12:00 +0800</lastBuildDate><item><title>【实习记】2014-09-26linux下恢复ntfs分区误删的文件</title><link>https://pythonwood.github.io/2014/09/%E3%80%90%E5%AE%9E%E4%B9%A0%E8%AE%B0%E3%80%912014-09-26linux%E4%B8%8B%E6%81%A2%E5%A4%8Dntfs%E5%88%86%E5%8C%BA%E8%AF%AF%E5%88%A0%E7%9A%84%E6%96%87%E4%BB%B6/</link><description>&lt;h3 id="_1"&gt;忧伤的背景&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;情景，ubuntu下把NTFS格式的盘中的“实习记”文件夹彻底删除了，追毁莫及，粗心觉不是一件好的事情。&lt;/p&gt;
&lt;p&gt;linux下回复ntfs盘下的文件不能用ext3grep，而使用debugfs命令实在很原始。&lt;/p&gt;
&lt;p&gt;万幸所有记录文件的文件名都是：【实习记】2014-0&lt;em&gt;*&lt;/em&gt;*.txt&lt;/p&gt;
&lt;p&gt;最后使用ntfsundelete + chown + chmod + sed&amp;nbsp;完美恢复刚才删除是所以TXT文件。&lt;/p&gt;
&lt;h4 id="0"&gt;0、&lt;a class="headerlink" href="#0" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;sudo …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">pythonwood</dc:creator><pubDate>Fri, 26 Sep 2014 15:07:00 +0800</pubDate><guid isPermaLink="false">tag:pythonwood.github.io,2014-09-26:/2014/09/【实习记】2014-09-26linux下恢复ntfs分区误删的文件/</guid><category>实习</category><category>linux</category><category>ntfs</category><category>文件恢复</category></item><item><title>【实习记】2014-08-29算法学习Boyer-Moore和最长公共子串（LCS）问题——阿里校招题</title><link>https://pythonwood.github.io/2014/08/%E3%80%90%E5%AE%9E%E4%B9%A0%E8%AE%B0%E3%80%912014-08-29%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0Boyer-Moore%E5%92%8C%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88LCS%EF%BC%89%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E6%A0%A1%E6%8B%9B%E9%A2%98/</link><description>&lt;!--
昨天的问题
方案一：寻找hash函数，可行性极低。
方案二：载入内存，维护成一个守护进程的服务。难度比较大。
方案三：使用前5位来索引，由前3位增至前5位唯一性，理论上是分拆记录扩大100倍，但可以就地利用mysql，最易行。
方案四：使用方案三，但增加一个表以减少冗余，但代价新开一个表，并且每次查询都select join两个表。
--&gt;

&lt;h3 id="_1"&gt;最长公共子串问题分析&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;其实这是一个序贯决策问题，可以用动态规划来求解。我们采用一个二维矩阵来记录中间的结果。这个二维矩阵怎么构造呢？直接举个例子吧：&amp;rdquo;bab&amp;rdquo;和&amp;rdquo;caba&amp;rdquo;(当然我们现在一眼就可以看出来最长公共子串是&amp;rdquo;ba&amp;rdquo;或&amp;rdquo;ab&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;b　　a&amp;nbsp;b&lt;/p&gt;
&lt;p&gt;c　　0　　0&amp;nbsp;0 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">pythonwood</dc:creator><pubDate>Fri, 29 Aug 2014 21:23:00 +0800</pubDate><guid isPermaLink="false">tag:pythonwood.github.io,2014-08-29:/2014/08/【实习记】2014-08-29算法学习Boyer-Moore和最长公共子串（LCS）问题——阿里校招题/</guid><category>阿里</category><category>校招</category><category>实习</category><category>算法</category><category>最长公共</category><category>子串</category><category>字符串</category><category>动态规划</category></item><item><title>腾讯2014实习面经——记一个非计算机学生的首次面试</title><link>https://pythonwood.github.io/2014/04/%E8%85%BE%E8%AE%AF2014%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E4%B8%AA%E9%9D%9E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%94%9F%E7%9A%84%E9%A6%96%E6%AC%A1%E9%9D%A2%E8%AF%95/</link><description>&lt;p&gt;地点：华南理工大学大学城校区，为广州考点。&lt;/p&gt;
&lt;p&gt;流程：网申3.X + 笔试4.12 + 一面4.15 + 二面4.17 + 三面4.19 +&amp;nbsp;签约4.25&lt;/p&gt;
&lt;h3 id="_1"&gt;前言&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;腾讯实习招聘笔试到拿到offer（软件工程师-研发反向），历时两星期 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">pythonwood</dc:creator><pubDate>Wed, 30 Apr 2014 23:58:00 +0800</pubDate><guid isPermaLink="false">tag:pythonwood.github.io,2014-04-30:/2014/04/腾讯2014实习面经——记一个非计算机学生的首次面试/</guid><category>面试</category><category>腾讯</category><category>实习</category><category>校招</category></item></channel></rss>