{"pages":[{"text":"\n\n\n\n\n\n  代码\n | 人生苦短，我用Python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments)};\n    gtag('js', new Date());\n    gtag('config', 'UA-109845932-1');\n    \n\n\n      (adsbygoogle = window.adsbygoogle || []).push({\n        google_ad_client: \"ca-pub-3784870097299714\",\n        enable_page_level_ads: true\n      });\n    \n\n\n\n\n\n\n\n人生苦短，我用Python\n\n\nLinux迷+Python粉 人生苦短，我用Python\n\n\n\n\n\nToggle navigation\n\n\n\n\nLinux迷+Python粉\n\n\n\n\n\n首页\n\n\n技术\n\n\n生活\n\n\n视频\n\n\n代码 (current)\n\n\n关于\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n代码\n参加过的项目\n\n\n \n\n    GitHub\n  \n \n\n    PythonTip\n  \n\n\n\n\n\n\n我发起的开源项目\n\n\n\n\nChrome插件jumper\nA chrome extend for JINAN university jwc website\n\nAuthor\njavascript\n\n\n\n\n\n\n\n\n\n\n购物下单网站\n腾讯实习的C++的web虚构练习项目\n\nAuthor\nC++\n\n\n\n\n\n\n\n\n\n\n我参与的开源项目:\n\n\n\n\n\nplumage\nTheme for Pelican, the static site generator. \n\nContributor\npelican\nplumage\n\n\n\n\n\n\n\n\n\n\n\ntwisted-intro-cn\nTwisted与异步编程入门 \n\nContributor\npython\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n资料\n\n \n\n    Github\n  \n \n\n    旧博客\n  \n\n\n\n简历\n\n \n\n    LinkedIn\n  \n \n\n    PDF简历\n  \n\n\n\n用以下方式浏览\n\n 分类\n 日期\n 标签\n\n\n\nCopyright信息\n© Copyright 2013-2017 Pythonwood.\n如未特别说明，本网站的内容使用如下协议Creative Commons\nAttribution-NonCommercial-ShareAlike 4.0 International license.\n\n\n免责声明\n本网站所表达的所有观点均为我个人的观点，并不代表我以前，现任和未来雇主或其任何关联机构，合作伙伴或客户的意见。\n\n\nRSS订阅更新\n\n 获取更新 (Atom)\n 获取更新 (RSS)\n\n\n\n\n 回到顶部\n\n\n          博客使用Pelican驱动\n          感谢Kevin Deldycke原创 Plumage 主题\n        \n\n\n\n    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n    ga('create', 'UA-109845932-1', 'auto');\n    ga('send', 'pageview');\n    \n\n\n    var _hmt = _hmt || [];\n    (function() {\n      var hm = document.createElement(\"script\");\n      hm.src = \"https://hm.baidu.com/hm.js?485d19a1d6970625620ed76e6b7ccf4b\";\n      var s = document.getElementsByTagName(\"script\")[0]; \n      s.parentNode.insertBefore(hm, s);\n    })();\n    \n\nvar cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan style='display:none;' id='cnzz_stat_icon_1270496461'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s13.cnzz.com/z_stat.php%3Fid%3D1270496461%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E\"));\n\n \n\n\n\n\n\n\n\n\n","title":"  代码\n | 人生苦短，我用Python","url":"https://pythonwood.github.io/code/index.html","tags":""},{"text":"\n\n\n\n\n\n  视频推荐\n | 人生苦短，我用Python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments)};\n    gtag('js', new Date());\n    gtag('config', 'UA-109845932-1');\n    \n\n\n      (adsbygoogle = window.adsbygoogle || []).push({\n        google_ad_client: \"ca-pub-3784870097299714\",\n        enable_page_level_ads: true\n      });\n    \n\n\n\n\n\n\n\n人生苦短，我用Python\n\n\nLinux迷+Python粉 人生苦短，我用Python\n\n\n\n\n\nToggle navigation\n\n\n\n\nLinux迷+Python粉\n\n\n\n\n\n首页\n\n\n技术\n\n\n生活\n\n\n视频 (current)\n\n\n代码\n\n\n关于\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n视频推荐\n视频那些事\n\n\n\n\n\n\n\n\n\n\n\nsikana视频:学习自由泳\n\nDocumentary\n游泳\n学习\n\n\n\n\n\n\n\n\nsikana视频:学习仰泳\n\nDocumentary\n游泳\n学习\n\n\n\n\n\n\n\n\nsikana视频:学习蛙泳\n\nDocumentary\n游泳\n学习\n\n\n\n\n\n\n\n\n麻省理工学院公开课：算法导论\n\nDocumentary\n算法\n推荐\n学习\n\n\n\n\n\n\n\n\n打，打个大西瓜\n\nDocumentary\n推荐\n\n\n\n\n\n\n\n\n\n\n\n\n资料\n\n \n\n    Github\n  \n \n\n    旧博客\n  \n\n\n\n简历\n\n \n\n    LinkedIn\n  \n \n\n    PDF简历\n  \n\n\n\n用以下方式浏览\n\n 分类\n 日期\n 标签\n\n\n\nCopyright信息\n© Copyright 2013-2017 Pythonwood.\n如未特别说明，本网站的内容使用如下协议Creative Commons\nAttribution-NonCommercial-ShareAlike 4.0 International license.\n\n\n免责声明\n本网站所表达的所有观点均为我个人的观点，并不代表我以前，现任和未来雇主或其任何关联机构，合作伙伴或客户的意见。\n\n\nRSS订阅更新\n\n 获取更新 (Atom)\n 获取更新 (RSS)\n\n\n\n\n 回到顶部\n\n\n          博客使用Pelican驱动\n          感谢Kevin Deldycke原创 Plumage 主题\n        \n\n\n\n    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n    ga('create', 'UA-109845932-1', 'auto');\n    ga('send', 'pageview');\n    \n\n\n    var _hmt = _hmt || [];\n    (function() {\n      var hm = document.createElement(\"script\");\n      hm.src = \"https://hm.baidu.com/hm.js?485d19a1d6970625620ed76e6b7ccf4b\";\n      var s = document.getElementsByTagName(\"script\")[0]; \n      s.parentNode.insertBefore(hm, s);\n    })();\n    \n\nvar cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan style='display:none;' id='cnzz_stat_icon_1270496461'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s13.cnzz.com/z_stat.php%3Fid%3D1270496461%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E\"));\n\n \n\n\n\n\n\n\n\n\n","title":"  视频推荐\n | 人生苦短，我用Python","url":"https://pythonwood.github.io/video/index.html","tags":""},{"text":"404找不到页面 你访问的页面不存在怎么办？ 用google或百度搜索下关键字吧。","title":"404","url":"404/","tags":"技术"},{"text":"","title":"50x","url":"50x/","tags":"技术"},{"text":"我是 Pythonwood ，林中之蛇。一个依然对世界怀有好奇心并孜孜不倦折腾着的人。 经历: 大学自学编程，从C/C++入门到后来因编程而了解了Linux打开了新世界，再后来被老师带入python大法，觉得Linux+Python组合力量非凡。曾经在腾讯、阿里都工作过不长的时间，非典型程序员。 Linux: 研究汇编，研究计算机原理事发现的事物。从此打开了一个新世界。 Python: 为了解决一个问题，先找出所有方法，最后只剩下一个方法。这就Python，也是我的哲学。 \"只保留一个方法\"，这相对主观，并且也会改变的，但多数没有。那些改变也是因为找到更好的。 为什么编程我最喜欢python？ 因为python很有哲学感，而我喜欢哲学。 我的前半生 小学 是学奥数的，逆向思维让我终生收益（十分感谢教我麦×堂老师）。 初中 的时候，因一个物理电学知识点不解，有一点存疑。向物理老师提出并帮我申请了学校实验室的临时使用。 其中很多细节已经忘记了，只模糊记得老师说:\"现在很少学生能这样……\" 高中 的时候喜欢思考哲学，并对物理的质能守恒这个定律印象非常深刻，让我对事物规律的理解加深了一个层次。 大学 依然喜欢哲学，并在PHD的词意中找到一种心灵共振感觉。（哲学是科学之母，任何一门学科研究到极致都一定也会触达哲学阶段。） 因为本专业要死记的太多，转而自学计算机编程，兴趣使然，坚持到现在已经超过5年了。 关于网站 这个网站从找国外vps、购买域名指向国外NS、寻找合适的写博客方式，适应pelican并找好的主题和汉化，部署HTTPS+HTTP2等等，前前后后花了不少于半年才完成。 旧博客选择的是cnblogs.com，我认为那是纯粹而且质量较高的。因为不支持markdown，本着自定义到死的无畏折腾精神，自己动手慢慢就有现在你看到的这个博客了。 在2017年11月之前的文章都是从旧博客迁移过来的。","title":"关于","url":"about/","tags":"技术"},{"text":"2017年12月份，我身边一位做实体母婴商品店的老板陷入了一场微信小程序\"骗局\"，以每个小程序20800的价格投资了小程序，我一开始以也没发现很不妥，直到后来老板再次被忽悠买多了几个小程序才醒悟是这样一场骗局。 过程 骗子以展望小程序未来，小程序像域名那样具有唯一性，有品牌推广功能等等为噱头，诱骗店主购买小程序20800元。 半年后，四川一家野技公司加了店主微信，表示他的小程序名字非常唯一，价值高，有家天津科技公司愿意买，然后故意任由店主出价。最后谈到150万转让费。期间制造各种问题拖延时间，店主也认为升值快，担心卖早了，不想早早答应，\"配合\"拖延。 再有其他2家异地公司谈另一种合作模式，一切成本由科技公司出，有利润后，店主和公司按8：2分成。为增加信任，同时给出了一篇四海皆准的操作方案稿，并且互怼竞争方说自己公司才比较靠谱。 我开始介入，发现小程序可登录可运行，前台后台用户体验都极差，并有不能写收货地址等明显bug。但因为反馈后当日下午就修复了问题，就觉得这家公司还是靠谱的。我甚至还觉得店主可能真的捡到金了。毕竟在互联网工作，见过些大起大落的科技浪潮。风口之中，猪也能飞。 后来店主被忽悠，再入手2个20800元的小程序，签完文件交了钱才和我说。我终于才想清楚整件事情。——一边虚高价销售抢注和维护小程序的\"终身服务\"，一边装作有意收购出更离谱的高价造成店主认为小程序极具投资价值的幻觉。然后骗子让店主多买几个来挣更多钱。 因没有互联网经验，实体店主在被忽悠下爽口地多买几个。 认清这个行骗模式之后劝醒了店主，店主后来收回合约和钱，只损失了2000元。至于之前就有那个小程序，他表示就算了。此事至此结束。 证据难点 这个产品是一个能运行，能使用，能交易的空壳，除此之外毫无价值。 虽然明知那些小程序的劣质功能只值两、三千，卖了20800给实体店主，但是骗子可以咬定这个壳程序就值这个价。 互联网虚拟产品成本核算难问题。让你无法判定次品高卖这个事实。所以，这是一次高级的骗局，虽然能识破，但维权投诉没有用。 最近接触股市，中国股市的本质是不是类似呢？ 再比如比特币最近大起大落…… 大伪若真。假作真时假亦真。 参考 假冒腾讯公司1.98万卖小程序，各大小老板为何纷纷被骗？ http://www.newbelink.com/article/31911.html 注意微信小程序骗局 https://tieba.baidu.com/p/5249331035 警惕!北海出现\"1.98万抢注小程序\"骗局!已有人被骗惨,都要注意… http://www.sohu.com/a/203976441_185101","title":"个案分析：20800元的微信小程序抢注骗局揭秘","url":"2017/12/个案分析：20800元的微信小程序抢注骗局揭秘/","tags":"生活"},{"text":"PythonTip 里未攻克的题目，如 RSA密码方程 ，如今积累工作经验之后从新挑战，仍然失败未成功了。把过程记录分享下。 描述: 在RSA密码体系中,欧几里得算法是加密或解密运算的重要组成部分。它的基本运算过程就是解 (x*a) % n = 1 这种方程。 其中，x,a,n皆为正整数。现在给你a和n的值(1 < a,n < 140000000)，请你求出最小的满足方程的正整数解x（保证有解）. 如：a = 1001, n = 3837，则输出23。 分析： 没头绪，在讨论里看时恍然，用到小学奥术内容辗转相除法（求最大公约数）了。如果 (x*a) % n = 1 变成 (x*a) % n = 0 ， 那x*a就是a和n公倍数了。如果这是小学奥数题，就先用辗转相除法得最大公约数，而最小公倍数用两数积除以最大公约数得出来。 rsa的原理数学基础欧几里得算法和小学奥数有着这样的联系，发现这点让我觉得不可思议又略有惊叹。看来学小学奥数有用，至少是可以为算法编程做准备的，学到了最朴素的数论。 辗转相除法（朴素欧几里得算法，中国余数定理，韩信点兵） （引用自 数论——欧几里得算法 ） 欧几里得算法，又名辗转相除法，是求最大公约数的算法。两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（252 = 21 × 12；105 = 21 × 5）；因为252 − 105 = 147，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。 题目语义转化 求这样一个数x*a，能被a整除，被n整除余1。 这就很形似 有一个数除以3余2，除以5余3，除以7余4，除以9余5．这个数至少是? 被称为 中国余数定理 扩展欧几里德算法 基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明：设 a>b。 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时 设 ax1+by1=gcd(a,b); bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b) b)y2=ay2+bx2-(a/b) by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 … 同余方程 ax≡b (mod n)对于未知数 x 有解，当且仅当 gcd(a,n) | b。且方程有解时，方程有 gcd(a,n) 个解。 求解方程 ax≡b (mod n) 相当于求解方程 ax+ ny= b, (x, y为整数) 我的一个另类编程解法（融合了辗转相除法思想）。 算法描述 (x*a) % n = 1 对应 方程 ax - ny = 1 的整数解 （a,n必定互质。如不互质可提取公因子，公因子*X=1，与X为整数矛盾） 化简降解方程分两情况： a>=n 时 变形为方程 (a mod n)x - n(y-[a/n]x) = 1 有整数解 a<n 时 变形为方程 a(x-[n/a]a) - (n mod a)y = 1 有整数解 无论那一种都变回 ax - ny = 1 的形式。所以重复化简，因a,n互质，最后会到达a,n其一是1的情况。 例子说明： 求能被9整除，被7除余1的最小数 9x=1(mod7) 对应方程 9x - 7y = 1 的整数解 变形有2x - 7(y-x) = 1 然后令 x_1=x, y_1=y-x 得方程 2x_1 - 7y_1 = 1 变形有2(x_1-3y_1) - y_1 = 1 然后令 x_2=x_1-3y_1, y_2=y_1 得方程 2x_2 - y_2 = 1 显然有解 x_2=1 y_2=1 好了，往上一步一步回溯得最初的x,y值 (x_2,y_2), (x_1,y_1), (x,y) 分别为(1,1),(4,1),(4,5) 9x = (9 4 mod 9 7) = 36 答：求能被9整除，被7除余1的数是36 python语言是弱递归化语言， python之父说递归都可以转成循环。所以我用递归后，转循环了。 Python代码: ################################################################################ # print \"F: 答案错误 循环解法\" ################################################################################ def gcd ( a , n ) : # 辗转相除求最大公约数 if a < n : a , n = n , a while n ! = 0 : a , n = n , a %n return a def exgcd ( a , n ) : # ax = 1 ( mod n ) 即 ax - ny = 1 求x , y # print a , n if gcd ( a , n ) ! = 1 : raise Exception ( 'fei hu zhi' ) # 先检查是否互质 l = [] while a ! = 1 and n ! = 1 : # a , n总会有个先到1，触底条件就是1 l . append (( a , n )) if a > n : a , n = a %n,n else : a , n = a , n %a if a == 1 : p = ( n + 1 , 1 ) elif n == 1 : p = ( 1 , a - 1 ) for a , n in l [ ::- 1 ] : if a > n : p = ( p [ 0 ] % n, (a//n*p[0]+p[1]) % a) # 这个值也是解，但没有最简：return (p[0], a//n*p[0]+p[1]) else : p = (( p [ 0 ] + n // a * p [ 1 ]) % n, p[1] % a) # 这个值也是解，但没有最简：return (p[0]+n//a*p[1], p[1]) return p print exgcd ( a , n ) ################################################################################ # print \"F: 答案错误 递归解法\" ################################################################################ def gcd_r ( a , n ) : # 辗转相除求最大公约数 if a * n == 0 : return a + n return gcd_r ( a %n,n) if a>=n else gcd_r(a,n%a) # print gcd(a,n) def exgcd_r ( a , n ) : # ax = 1 ( mod n ) 即 ax - ny = 1 求x , y # a , n总会有个先到1，触底条件就是1 # print a , n if gcd_r ( a , n ) ! = 1 : raise Exception ( 'fei hu zhi' ) # 先检查是否互质 if a == 1 : return ( n + 1 , 1 ) if n == 1 : return ( 1 , a - 1 ) if a > n : p = exgcd_r ( a %n, n) return ( p [ 0 ] % n, (a//n*p[0]+p[1]) % a) # 这个值也是解，但没有最简：return (p[0], a//n*p[0]+p[1]) else : p = exgcd_r ( a , n %a) return (( p [ 0 ] + n // a * p [ 1 ]) % n, p[1] % a) # 这个值也是解，但没有最简：return (p[0]+n//a*p[1], p[1]) print exgcd_r ( a , n ) 小学初中就知道数论，数论真有魅力，非常漂亮。 参考 数论——欧几里得算法 https://xuanwo.org/2015/03/11/number-theory-gcd/ 欧几里德与扩展欧几里德算法 http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html 欧几里得算法（辗转相除法） https://my.oschina.net/u/1780798/blog/646739 https://zhidao.baidu.com/question/406531667.html?qbl=relate_question_3","title":"RSA原理：欧几里德算法与奥数内容辗转相除法——挑战PythonTip","url":"2017/12/RSA原理：欧几里德算法与奥数内容辗转相除法——挑战PythonTip/","tags":"技术"},{"text":"PythonTip 里未攻克的题目，如 取石子游戏 ，如今积累工作经验之后从新挑战，成功了。把过程记录分享下。 描述: 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法， 一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。 现在给出初始的两堆石子的数目a和b，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 如果你是胜者，输出Win,否则输出Loose。 例如，a=3,b=1, 则输出Win(你先在a中取一个，此时a=2，b=1,此时无论对方怎么取，你都能将所有石子都拿走). 分析（动态规划）： 我的思路是转变成图形化表示，二维表中点(x,y)用W表示会赢，L表示为输。 (x,y)的结果显然决定与前面已填好的(m,n) , 其中m,n 分别小于 x,y 。 所以可以用动态规划。 根据之前失败坐标的集合推算本行的失败坐标。 并且每行至多有一个失败坐标。所以能保证动态规划的时间复杂度不会很高。 当我从(0,0)开始，填到(a,b)时就知道结果了。 明显(x,y)和(y,x)结果一样，因此我刚开始只填半个表，导致结果不准，看了其他人的奇异坐标才明白到自己的错误。从新填好。 错误填表分析过程 我根据这个过程写出版本一代码。 正确填表分析过程 我本来猜测需要推到前面代码从来。幸运的是，运行正常的版本二的代码只在版本一加一行就可以了。 下面是我的算法代码，比较简洁。动态规划确实强大，另外还有分治法也强。 Python代码: ################################################################################ # print \"T: 二维坐标表示法, 每行至多有一个失败坐标。二维表只填半边导致失误，改正\" ################################################################################ if a < b: a,b = b,a m = [(0,0)] # 失败的坐标纪录池 for i in range(1,a+1): for j in range(i+1): # if i == j or j == 0: # win # continue for x in m: if (i-x[0]) == (j-x[1]) or i == x[0] or j == x[1]: # win break else: # else 是for的部分，break for的时候也break了else m.append((i,j)) # 版本一：二维表只填半边，所以只有这行代码 m.append((j,i)) # 版本二：二维表两边都填，多加这一行就OK了 #print i,j,m print \"Loose\" if (a,b) in m else \"Win\"","title":"威佐夫博弈：取石子游戏算法——挑战PythonTip","url":"2017/12/威佐夫博弈：取石子游戏算法——挑战PythonTip/","tags":"技术"},{"text":"PythonTip 提供了一个不错的学习算法平台，大学毕业前挑战进入了前几名 pythonwood解题数量 。 当时有些未攻克的题目，比如密码生成题目，如今积累工作经验之后从新挑战，成功了。把过程记录分享下。 描述: 生活在当代社会，我们要记住很多密码，银行卡，qq，人人，微博，邮箱等等。小P经过一番思索之后，发明了下面这种生成密码方法：给定两个正整数a和b, 利用a / b我们会得到一个长度无限的小数(若a / b不是无限小数，比如½=0.5,我们认为0.5是0.5000000…，同样将其看做无限长的小数），小P将该小数点后第x位到第y位的数字当做密码，这样，无论密码有多长，小P只要记住a,b,x,y四个数字就可以了，牢记密码再也不是那么困难的事情了。现在告诉你a,b,x,y（0 < a,b <= 20132013, 0 < x <= y < 100000000000),请你输出密码。例如：a = 1, b = 2, x = 1, y = 4, 则 a / b = 0.5000000…, 输出小数点后第1到4位数字，即5000 分析： 计算机浮点计算有精度问题，所以直接除法得结果的思路不通。这次我想到小学的列竖式除法算法本身是可以解无穷除法的。于是，这道题就是把我们小学早已学过的算法，用代码表示出来。 下面包含几个算法， 都比较简介，比较pythonic（在网上看到是算法代码普遍臃肿）。只有最后的循环记录法是在规定时间内通过的。 Python代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #! /usr/bin/env python #coding: utf8 # 返回a除以b的商的小数部分的第x位到第y位 a = 22 ; b = 300003 ; x = 1 ; y = 50 ################################################################################ print \"F: 不能引入sys 模拟手工除法\" ################################################################################ import sys t = a % b for c in range ( y ): t *= 10 if c + 1 >= x : sys . stdout . write ( str ( t // b ) ) t %= b print ################################################################################ print \"F: 时间复杂度不足 同上\" ################################################################################ code = \"\" t = a % b for c in range ( y ): t *= 10 if c + 1 >= x : code += str ( t // b ) t %= b print code ################################################################################ print \"F: 时间复杂度不足 变除为乘补零难\" ################################################################################ t = a % b lzero = \"\" _t = t * 10 while _t < b : lzero += \"0\" _t *= 10 print lzero + str ( t * 10 ** y // b )[ x - 1 :] ################################################################################ print \"F: 时间复杂度不足 同上\" ################################################################################ t = a % b lzero = \"\" _t = t * 10 while _t < b : lzero += \"0\" _t *= 10 print lzero + str ( int ( str ( t ) + '0' * y ) // b )[ x - 1 :] ################################################################################ print \"T: 挑战成功 循环小数记录法\" ################################################################################ code = \"\" # 遇见循环即止 rep = \"\" # 循环体 left = [] # 余数池 t = a % b for c in xrange ( y ): if t in left : rep = code [ left . index ( t ):] break else : left . append ( t ) t *= 10 code += str ( t // b ) t %= b else : print code [ x - 1 :] print ( code + rep * ( ( y - len ( code )) / len ( rep ) ) + rep [: ( ( y - len ( code )) % len ( rep ) ) ] )[ x - 1 :]","title":"Python解无穷大数除法算法——挑战PythonTip","url":"2017/12/Python解无穷大数除法算法——挑战PythonTip/","tags":"技术"},{"text":"总述 在大学里通过IPV6看过IPTV，最近一两年直播非常火，电视盒子也火了一把。于是想用kodi看直播电视。 kodi的低耗，无噪音，便宜的优点我觉得很适合做家庭多媒体服务中心。 第二次用树莓派安装kodi，没有上一次那么迷茫了。把一些有价值的东西记录下来。 一、安装Kodi（请务必一同安装kodi-pvr-iptvsimple） sudo apt-get install kodi kodi-pvr-iptvsimple 并不是raspbian安装kodi后就能看直播/电视了。如果没有安装kodi-pvr-iptvsimple，kodi侧栏的电视功能无响应，直播/TV的相关插件也会有问题。我花了不少时间才找到了原因。 如果出现kodi的插件里没有\"PVR客户端\"选项可设置，或者搜索不到PVR IPTV Simple Client相关插件，或者设置时出现错误提示信息Error，通过安装kodi-pvr-iptvsimple可解决。 二、设置kodi在无需桌面环境下随机自动运行 kodi可以通过非GUI的命令行启动，无需先启动桌面环境，非常省资源。 我做过实测树莓派3启动到命令行只需50MB内存，启动kodi播放则再增加100MB内存。总共只需150MB。如果启动桌面环境，桌面环境单独占用70MB内存。 先用 sudo raspi-config 命令设置boot选项，启动后自动登录到命令行模式（auto boot to cli）。 然后在pi用户的.bashrc命令中追加一行 ( cd /tmp; ps -ef | grep -v grep | grep kodi || DISPLAY=:0.0 nohup kodi ) 2>&1 >/dev/null & 这样树莓派每次都会启动到kodi，但不会多次运行kodi。 三、树莓派添加红外模块后实现电视遥控器控制kodi 虽然安装快控（kodi remote control）App或者yaste App可以在wifi环境下通过App远程控制树莓派运行的kodi。 然而我觉得每次先解锁手机，打开软件，然后只为点几下键体验不是很好。 所以，在老旧已坏的遥控飞机上拆下红外模块（对讲机，其他遥控玩具都会有这个模块，支持废物利用），结合家里旧的遥控器实现红外遥控树莓派。 我跟着这个教程 树莓派—红外遥控设置 设置成功 。 树莓派能识别红外遥控器后，就是树莓派kodi学习（映射）按键与指令对应关系的过程。 kodi配置键名（比如KEY_OK）和kodi动作的映射关系文件路径是/usr/share/kodi/system/Lircmap.xml。 以下面mediacenter类型的遥控设备为例，按下该设备某个键，对应lircd接受到ok指令，那么kodi执行select动作。 为了省事，我把其中键名最简洁 的xml段复制后 <remote device= \"mediacenter\" > ... <up> up </up> <down> down </down> <select> ok </select> <one> 1 </one> <two> 2 </two> ... </remote> 粘贴并修改device值 <remote device= \"guangdianyaokong\" > ... <up> up </up> <down> down </down> <select> ok </select> <one> 1 </one> <two> 2 </two> ... </remote> guangdianyaokong是我在/etc/lirc/lircd.conf文件的name字段名字，可自由修改。只要保持对应一致就可以了。 我录制irrecord命令如下，省事的原因是录键名的时候对应取up，down，1，ok等简单词。 irrecord -d /dev/lirc0 guangdianyaokong --disable-namespace 四、接下来自由发挥，对kodi自行研究，安装各种插件。 按照插件库然后从插件库安装插件，或者直接按照目标插件的zip包。 搜集m3u8直播列表，灌给PVR IPTV客户端使用。也可以使用 IPTV Tool 插件来托管PVR IPTV客户端 五、直播m3u8列表的url存活测试 导入播放器中手动测试 smplayer或者vlc都能打开m3u8文件进行网络播放。所以也能来测试是否存活。只是方法简单直接容易累。 可打开播放器界面中打开m3u8文件；命令行则可用smplayer ， 或者 vlc 打开。 脚本批量快速检测 （todo…） 提醒 熟悉Linux环境的话，完成一台树莓派环境配置之后，可随时备份，其它树莓派克隆环境就可以了。具体方法参考另一篇随笔。 树莓派SD卡Linux系统盘复制，10分钟克隆新机 参考 Kodi 开源多媒体播放器 - 神器 http://www.cnblogs.com/XieSir/articles/6287387.html 6款树莓派kodi插件推荐 https://www.htpcbeginner.com/raspberry-pi-kodi-addons/ 移动网络电视和IPTV的区别在哪里？ http://www.shafa.com/articles/zJmvNRrYFs6uzjhH.html","title":"树莓派安装kodi神器和红外遥控装置变身多媒体中心","url":"2017/12/树莓派安装kodi神器和红外遥控装置变身多媒体中心/","tags":"生活"},{"text":"2017年末，为了做推广，接触了广告的几方面的知识。网上找模板，做背胶海报、彩色横幅、H5宣传、户外喷绘广告，感觉算是当了小半个广告人。 因为不想用windows系统，奢望linux下也能做平面广告，只是简单活，修改模板换文字，心想ubuntu就可以吧，毕竟已经2017年了。 然而最终结果是尝试许多方法后终于放弃了。放弃之后发现有好的X宝店，同时修改贴心服务， 直达地址 ，然后我得救上岸了。 下面说说我用过的图像软件。 图像查看：ristretto 与 gthumb 与 gnuview ristretto 是 xfce桌面默认图像浏览器，显示快，反应迅速。是第一个让满意的地一个图像软件。 gthumb 比起 ristretto 更胜一筹，gthumb在打开5兆以上的高清图片比ristretto快，而且有侧栏目录数，右面主题显示缩略图功能，点到哪里显示到哪里很方便。 gnuview 界面和gthumb差不多，但是没有gthumb体验好，软件闲置中 初级图像处理：pinta pinta 是linux下的绘图工具，和windows下的画图有点像。能胜任简单的修改图片功能。 高级图像处理：gimp 和 krita 和 inkscape gimp 是开源界的PS，抠图，通道，蒙板，印章等等PS功能齐备。唯一的诟病就是对CMYK支持太差。虽然可以按照sperate插件导出为CMYK色彩模式，但是不能打开CMYK模式文件。查阅中英文资料并不信邪两天后（比如先用ps转换成rbg模式打开失败），我放弃了。gimp可打开成功部分PS文件，但更多的时候让我不满意。所以不建议你这样做。 krita 是支持打开CMYK色彩模式的psd文件的软件，而且成功率比gimp高，缺点是使用中发现cpu和内存占用率似乎比gimp高很多。更建议用krita在linux下打开psd文件。 inkscape 对应linux下打开cdr文件的软件， 但是由于CorelDRAW虽然号称是PS的补充但是老古董而且非常难用（xp下安装CorelDRAW弄了一天没成功，这个软件非常不好用），问了一位设计师后确认不再对这种cdr文件抱有幻想。 当然，最好方法还是安装虚拟机或者让 客服 帮你吧。 其他尝试 Linux安装wine1.8，然后能安装PS cs6绿色版本成功，但打开psd文件会崩溃。 设计素材、设计模板网站推荐 要用谷歌搜索，才能找到好的。 觅知网，千图网，包图网下载限制相对小，素材比较多。千库网虽然素材多，但对免费下载限制很强，同一个局域网的不同用户的总免费下载份额只有1个。 参考资料 超赞的 Linux 软件: https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/#图形 15个最好的Linux照片/图像编辑器我发现在2015年: https://www.howtoing.com/best-image-photo-editors-for-linux","title":"我的Linux下的图像软件使用记录","url":"2017/12/我的Linux下的图像软件使用记录/","tags":"生活"},{"text":"第二波研究树莓派功能了，上次主要是当作linux系统来研究，这次当作只能设备来研究。是奔着遥控式家庭影音的方案来研究的，树莓派的基础环境非常重要，所以从新理一理，记录下来。 一、奔着遥控式家庭影音的购买方案 经比较，树莓派在京东是挺贵的，鉴于是标准化带电子产品，去天猫买 树莓派 可以了。我没买SD卡，将旧的class10的16G的SD利用上(class10意思是写入速度约10MB/s)。 我购买并用上的： 公牛usb魔方插座 ， 树莓派 ， HDMI转VGA带供电 ，带开关按钮线的电源，杜邦线。 不用购买就用上的配件： 红外接收仪(从坏的遥控玩具拆下可用)，旧电视遥控器一个，老VGA显示屏，旧音箱。 我购买而还没用的可选配件： 七彩RGB的LED元件，面包板， HDMI转DVI ，光敏电阻。 我认为不用买的： 小屏幕（退货了），温度感应，五向摇杆，蜂鸣器，触摸感应器等。 二、树莓派安装官方的raspbian系统并初始化 基础部分教程： 包括修改Pi密码,修改国内源,显示中文，设置时区为Asia/Shanghai，安装开源中文字体 文泉驿 ，安装fcitx谷歌拼音，开启ssh服务，设置wifi连接密码 树莓派上手配置 https://yaogangli.gitbooks.io/raspberry-pi-learning/content/Raspbian.html 新手入门树莓派必做的四件事 http://blog.csdn.net/A_lPha/article/details/53116767 How to setup multiple WiFi networks? https://raspberrypi.stackexchange.com/questions/11631/how-to-setup-multiple-wifi-networks/11674 ssh服务配置 https://www.raspberrypi.org/documentation/remote-access/ssh/ 优化部分教程： 包括添加u盘自动挂载功能，VNC服务，优化无网络下树莓派开机时间等 树莓派USB存储设备自动挂载 http://www.jianshu.com/p/188828d9777a How to change timeout in systemctl https://unix.stackexchange.com/questions/186162/how-to-change-timeout-in-systemctl 安装VNC服务(tightvncserver) https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-14-04 配置与学习树莓派config.txt配置文件 https://www.zybuluo.com/SiberiaBear/note/328982 三、重要提醒： 经验证，我安装一大堆东西后，SD卡使用才4G，其中几百兆是音乐， 所以8G卡也是够用的。 熟悉Linux环境的话，完成一台树莓派环境配置之后，可随时备份，其它树莓派克隆环境就可以了。具体方法参考另一篇随笔。 树莓派SD卡Linux系统盘复制，10分钟克隆新机 四、参考 开始 Raspberry Pi 项目前需要知道的 10 件事 https://www.digikey.com.cn/zh/articles/techzone/2017/feb/10-things-to-know-before-starting-a-raspberry-pi-project 树莓派启动那些事 http://elmagnificogi.github.io/tags/#RaspberryPi","title":"树莓派初始化环境搭建的一些事","url":"2017/12/树莓派初始化环境搭建的一些事/","tags":"生活"},{"text":"2017年11月，正在折腾静态博客。最后使用了pelican生产+plumage主题并自行汉化。其中发现些许问题。 29号时，对plumage主题进行完善，并提交了一个修复不支持PAGINATION_PATTERNS参数问题的fixbug型 pull request 。 30号时，原作者 Kevin Deldycke 接受合并到了master。 纪念一下，这是第二次开源贡献，为pelican的plumge主题修改被owner接受。 第一次是2016年4月7日对开源书籍的 twisted-intro-cn 的贡献 修改鸭子模式介绍","title":"第二次开源贡献，为pelican的plumage主题修改被owner接受","url":"2017/12/第二次开源贡献，为pelican的plumage主题修改被owner接受/","tags":"技术"},{"text":"有旧和新树莓派二个，发现SD卡的raspbian系统可在不同树莓派之间通用，挺好。 学通树莓派系统克隆，兼备安装、备份与恢复能力。 在家里，用了一周时间，将新买的树莓派3， HDMI转VGA带供电 (性价比推荐)，旧显示屏，旧音箱。组成家庭媒体中心。手机使用bubbleupnp投屏和推送音乐播放，听音乐的享受更舒服了，显示屏再大些就更好。 在工作室，还有一个树莓派和支持HDMI输出的投影仪。如果能复制现有树莓派的系统SD卡，将省事不少。（重复的事应少做） 开始折腾尝试 借助我的个人电脑是ubutnu，可以看见树莓派分区情况，第二个分区14G采用了3G，很多空间是多余的。 用了1天的不断努力尝试终于才成功，囧。 失败1:使用DD或ddrescue 不幸的是我是从14.6G卡克隆到14.4G卡，使用dd失败是注定的。使用dd的必要条件是目标卡要更大。 失败2:源自笔记本linux系统迁移SSD的经验——分区一样，复制文件，改etc配置法。 linux磁盘迁移，只需分区格式化，复制文件，修改etc下的fstab和udev目录的网卡信息，chroot+grub安装。就能完成。 然而实践得知，不适用树莓派迁移。启动时卡在\"smsc95xx 1-1.1:1.0: eth0: register ‘smsc95xx' …\"之后。无法启动。 比较发现，复制时，不会有dev/by-partuuid/目录，而本身树莓派是有这个目录的。 成功:dd读取为raw镜像盘、resize2fs缩容分区、qemu-img缩容disk、dd写入成功启动树莓派 先dd读取物理盘为raw格式镜像盘。这样就可以方法搞，最坏情况也不影响已有的系统sd卡内容。 $sudo dd if=/dev/sdb of=/home/16G.img bs=128K 挂载loop设备以便于gparted能操作 $sudo losetup /dev/loop0 /home/16G.img $sudo partprobe /dev/loop0 # 运行后才会出现分区/dev/loop0p1,/dev/loop0p2 第二分区从14G缩容到6G（实际是把分散的Block数据集中到前6G位置。非真正改变分区大小） $sudo e2fsck -f /dev/loop0p2 $sudo resize2fs /dev/loop0p2 6G GParted / Fdisk 更改第二分区为6G GParted /dev/loop0打开，然后选择第二分区右击，选择\"更改/移动大小\"。设置。 卸载恢复loop设备: $sudo partprobe -d /dev/loop0 $sudo losetup -d /dev/loop0 raw虚拟磁盘缩容 $sudo qemu-img resize /home/16G.img -8G $qemu-img info /home/16G.img image: xxx.img file format: raw virtual size: 5.9G (6380060672 bytes) disk size: 5.9G 使用DD写入新SD卡，启动成功。 可选：写入sd后可以用resize2fs扩容分区完全用上SD卡空间，参考上面缩容。 总结提升 linux下安装树莓派系统到SD卡，使用dd刻录后还有剩余空间，用resize2fs可让最后分区来占满。 使用dd来备份整个硬盘太慢，可以用resize2fs将数据块移动到前面，parted缩小分区，然后刻录硬盘前面有数据部分即可。这样备份文件就不会臃肿。 备份镜像恢复时，过程类似初次安装系统。 参考 把一块硬盘上的 Linux 系统整个复制到新硬盘上的方法. https://www.v2ex.com/t/183310 openstack文档 http://docs.ocselected.org/openstack-manuals/kilo/image-guide/content/ch_modifying_images.html#losetup-kpartx-nbd 使用qemu-img改变镜像文件大小 http://niusmallnan.com/_build/html/_templates/knowladge/resize_raw_file.html 笔记本硬盘更换记（使用LVM进行在线数据迁移） http://cathay4t.blogspot.hk/2009/05/lvm.html 新电脑+旧系统：教你在不同机器间转移Linux http://www.geekfan.net/1860/ usb-creator-gtk 方法和 clonezilla方法没有深入研究。","title":"树莓派SD卡Linux系统盘复制，10分钟克隆新机，raspbain备份恢复","url":"2017/11/树莓派SD卡Linux系统盘复制，10分钟克隆新机/","tags":"技术"},{"text":"DLNA (数字生活网络联盟)是数码生活中一个非常方便简单实用的技术名字。它做了一件伟大的事情，就是连接到支持DLNA的设备，并通过无线方式无缝传输数据 —— 照片，音乐，视频甚至是手机屏幕上的数据。（随时+实时的多屏互动，适合家庭分享） 这是一个非常古老而富有活力的格式。曾经，微软和索尼都试图从Xbox One和PS4上分别去掉这功能，但是由于需求的人众多，后来有重新加入去。所以，让我们高呼DLNA万岁吧！ 有部分很好的（也有很多糟糕的）Android应用程序使用DLNA流媒体技术，所以我们选择了6款最好的DLNA客户端APP推荐给你。 1. MediaMonkey MediaMonkey远不只是DLNA客户端，它还可以让你通过WiFi，UPnP，蓝牙以及DLNA，在多个设备上同步和流媒体。 特点是整洁的界面和丰富的媒体管理小工具，维护多媒体库 —— 包括播放列表管理，批量文件编辑和书签管理等等。 遗憾的是你需要支付才能使用额外的部分功能，例如无限制的DLNA播放器。然而，花点小钱就能得到一个最完整的流媒体应用之一的APP所有功能，在我们看来还是可接受的。 2. Airwire 在苹果商店上Airwire是评分最高的DLNA应用程序之一。对大部分挑剔的安卓版本用户来说，安卓版airwire仍是投屏到大屏幕上的不错选择。发现设备速度很快，并且保持很好的同步和质量。尽管已经没有更新，AirWire仍然是最可靠的DLNA流媒体播放选择之一。 AirWire兼容多种设备，包括最新的控制台和许多较老的大品牌智能电视。 3. BubbleUPnP（译者推荐） 安装BubbleUPnP UPnP/DLNA这款软件，能直接从手机向支持DLNA的设备广播您的内容。 它支持Chromecast，有DLNA功能的电视和最新的游戏控制器。 除了基本的流媒体功能外，它还具有播放队列，编辑播放列表，刻录，定时睡眠和随机播放模式等各种功能。更令人满意的是，它还有全屏图像查看器和遥控功能。 正如好些极客软件一样，不仅好用，而且还不收费！ APK下载地址： BubbleUPnP Server官网下载 4. MediaHouse UPnP/ DLNA 浏览器 如果你喜欢有更多功能的APK，请考察下MediaHouse UPnP/DLNA浏览器。包含多种DLNA流媒体功能，用您想要的方式共享视频和音乐。例如，它会自动扫描您的WiFi网络，查看是否有任何DLNA设备，之后可选连不连接。 它将扫描到的DLNA设备分为两类，第一类是可以将内容流式传输的设备，第二类是可以从中读取文件的设备。支持为音乐文件创建播放列表，附带图像查看，并可工作在横向模式。 5. iMediaShare Personal 如果你想要一个界面炫酷的DLNA应用程序，那iMediaShare个人版很适合你。 这个APP可以将数字媒体直接从Android设备（手机/平板）传输到电视机而无需使用任何电缆。 在您的电视上播放媒体时，该APP还作为您控制媒体的遥控器。 支持使用手势来控制播放过程，比如暂停，继续等等。 6. AllCast 尽管上面列出的APP都能将内容流式共享到任何DLNA设备，但AllCast是其中兼容性最好的。 它可以将媒体流式传输到Chromecast，Amazon Fire TV ，Apple TV ，Xbox 360和Xbox One，PS4以及其他所有支持DLNA的设备。 它也可以让你从你的Dropbox输入，直接读取视频流内容，无需先下载。 结论 只需让老旧硬盘通过无线你就可以做这么美好的事情。设置DLNA可能听起来有点复杂，只是因为它是一个长的复杂的技术术语，但它其实真的很容易。 以上应用程序都非常好，挑选最适合您的那个DLNA客户端APP，然后按照屏幕指示操作，你就向无线媒体中心型的数码生活更进一步了。","title":"[译]安卓6款最佳DLNA,UPNP流媒体客户端APP","url":"2017/11/[译]安卓6款最佳DLNA,UPNP流媒体客户端APP/","tags":"生活"},{"text":"量化金融刚结果：计算出差了一分钱的涨停价 量化金融用Python，最近在处理浮点问题的时候，发现一个问题，比较有意思，分享出来。 python计算79.035的四舍五入结果是79.03，这是错误的。 以下是IPython中输入程序语句，IPython能即时编译运算和输出结果。 # 计算71.85的涨停价 In [1]: 71.85 * 1.10 Out[1]: 79.035 # 涨停价四舍五入应该是79.04，但由精度损失，只有79.03。 In [2]: round(71.85 * 1.10, 2) Out[2]: 79.03 原因分析 这个问题和Python语言本身无关，原因是浮点数即小数在 计算机的二进制化标准 有关。 所以很多计算机语言都存在浮点精度损失问题，但庆幸python已有解决方法。Python已经写出了一些库，能屏蔽下层计算机架构带来的浮点问题。 Python浮点运算的正确方法 Python解决浮点精度问题的办法是使用 decimal 库。 In [ 26 ]: from decimal import * In [ 31 ]: print Decimal ( 79.035 ) . quantize ( Decimal ( '.01' ), rounding = ROUND_HALF_UP ) 79.04 为此我特地写了邮件，写出期望优矿支持引入 decimal 库。得到回复说优矿下一个版本中引入。 （更新：到了5月份确实可以引入decimal库了，至此问题解决） 参考 谈谈关于Python里面小数点精度控制的问题 http://www.cnblogs.com/herbert/p/3402245.html","title":"Python量化之数据处理——小数浮点精度问题解决","url":"2017/04/Python量化之数据处理——小数浮点精度问题解决/","tags":"技术"},{"text":"0、前言 nc是一个在网络连接两端的好工具，同时也是也个临时的端口转发的好工具。（永久的端口转发用什么？用iptables） ssh也是这方面的好工具，好处是加密可靠可复用在一端操作即可，代价是要有登录帐号。 我们知道， SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是， SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。 1、隧道带理 典型应用：翻越高墙 需要条件：一个国外vps，一个不需要登录（安全）的帐号，一个命令。 vps新建帐号： useradd -g nobody -s /sbin/nologin gfw && echo gfw_Passw0rd | passwd --stdin gfw 本地ssh连接： ssh -NfD 6666 gfw@vps -p 2222 可选转换：使用privoxy把socks5代理变成http代理供svn，pip，gem，curl等工具使用。 2、本地端口转发 我们可以将远程机器（LdapClientHost）上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）。在 LdapClientHost 上执行如下命令即可建立一个 SSH 的本地端口转发，例如： ssh -L 7001:localhost:389 LdapServerHost 之后的数据流将会是下面这个样子： 我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上， 而本机的 SSH Client 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Server 上。 SSH Server 会解密收到的数据并将之转发到监听的 LDAP 389 端口上， 最后再将从 LDAP 返回的数据原路返回以完成整个流程。 3、远程端口转发 我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上，而本机的 SSH Server 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Client 上。 在 LDAP 服务器（LdapServertHost）端执行如下命令： ssh -R 7001:localhost:389 LdapClientHost 区别： SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 。而我们的应用也是有方向的，比如需要连接 LDAP Server 时， LDAP Server 自然就是 Server 端，我们应用连接的方向也是从应用的 Client 端连接到应用的 Server 端。如果这两个连接的方向一致，那我们就说它是本地转发。而如果两个方向不一致，我们就说它是远程转发。 4、使用autossh防网络抖动+supervisior进程守护。 autossh解决的问题：远程端口转发一旦端口，很难再次建立。 autossh -M 1932 -NR 1922:localhost:1122 user@vps -p 1122 ps可以看到实质是这样的： ssh -L 1932:127.0.0.1:1932 -R 1932:127.0.0.1:1933 -NR 1922:localhost:1122 -p 1122 user@vps 分析：使用回路，将本地1933端口，（远程转发）映射到远端1932，（本地转发）到本机的1932。形成回路。 supervisior解决的问题：autossh的进程守护 因此，使用supervisior守护autossh，autossh守护ssh。达到自动启动和守护端口转发的目的。 5、综合使用 案例一、如何2222端口被封，如果绕过封死2222端口的防火墙直接ssh到内网机器。（就是说限某几个端口是有局限的） 1、登录最重要的机器把2222端口映射到12222端口： ssh -gfNL 12222:0.0.0.0:2222 localhost -p2222 2、使用该机器做隧道代理访问其他内网机器： ssh -NfD 10000 user@host -p12222 3、ssh绕道访问其他内网机器： ssh -o \"ProxyCommand=nc -x localhost:10000 %h %p\" user@host -p2222 巧妙结合的ssh和nc，都是linux自带工具，没有依赖。 案例二、借助远程vps让两台不能直接相通的机器相互能访问。 有主机vps和主机A、B。A、B无法直连，通过\"中介\"搭桥相连。（两台机器都能主动ssh到vps就能完成。） A要ssh到B（B要ssh到A是同理）： 1、主机B用ssh远程转发自己的2222端口到vps的127.0.0.1:12222 ssh -NfR 12222:127.0.0.1:2222 user@vps -p2222 2、主机A用ssh本地转发vps的127.0.0.1:12222到本地的127.0.0.1:12222 ssh -NfL 12222:127.0.0.1:12222 user@vps -p2222 3、主机A登录主机B ssh user@localhost -p12222 参考： 实战 SSH 端口转发 https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/ 使用supervisor托管shadowsocks https://blog.phpgao.com/supervisor_shadowsocks.html SSH反向连接及Autossh http://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html","title":"ssh命令：隧道代理+本地端口转发+远程端口转发","url":"2016/02/ssh命令：隧道代理+本地端口转发+远程端口转发/","tags":"技术"},{"text":"nc命令全名为netcat，顾名思义就是通过TCP或UDP从网络读写数据。 很多事情不一定非得抓包，nc也能发挥巨大作用。 1、传输文件 使用<>重定向符（只适用单文件，不推荐、失败时 \">\" 产生空文件） nc -l 8888 < demo.txt # 在本机8888端口侦听TCP连接，将收到的数据写入文件 nc ip 8888 > demo.txt # 文件接收端：将文件内容通过网络\"cat\"到远端 使用tar传输文件（推荐，好处是保留了原目录结构和权限） tar cz demo1.txt demo_dir/ | nc -l 8888 # 监听8888端口，有连接时开始tar打包并\"cat\"到远端 nc ip 8888 | tar zx # 连接、接收数据、解压一步到位。 2、建立网络管道 nc -l 8888 # 接收消息 echo msg | nc ip 8888 # 发送消息 3、迁移生产机房数据到测试机房（运维电脑建管道） tar cz demo1.txt demo_dir/ | nc -l 8888 # 生产机房ipA nc -l 8888 | tar zx # 测试机房ipB nc ipA 8888 | nc ipB 8888 # 运维个人电脑，连通两台机器的8888端口。 4、测试网络连通 （排查测试机房的lbg转发udp问题） curl 调试http，即7层非常高效。但如何调试4层网络呢？答案就是nc 测试机房lbg做了公网udp服务的映射，但测试同学发现程序出错，怀疑网络问题，找运维同学排查。 nc -ul 9999 # 服务ipS 监听9999端口 该端口映射到公网 ipVS:portVS nc -zuv ipS 9999 # 内网udp连通成功 显示Connection to ipS 9999 port [udp/*] succeeded! nc -zuv ipVS portVS # 公网udp连通失败 显示Connection to ipVS portVS port [udp/*] fail! 一、上如何检查tcp？以上的参数u去掉，默认就是tcp。 二、进一步写出nagios插件，检查udp服务端口（以部署在PP的udp消息推送监控中） 5、代替telnet，测试mc，浮云等等。 echo -e \"stats\\r\\n\" | nc ipS portMC # 非交换式查看mc的状态。 echo -e \"INFO\\r\\n\" | nc ipS portREDIS # 非交换式查看redis的状态。 6、使用nc发邮件，发送http请求，反弹shell，端口转发等等，请man nc echo -e \"GET / HTTP/1.0\\r\\n\" | nc uc.cn 80","title":"不能小看的nc——实践TCP协议第四层的软件（传输层）","url":"2015/12/不能小看的nc——实践TCP协议第四层的软件（传输层）/","tags":"技术"},{"text":"忧伤的背景 情景，ubuntu下把NTFS格式的盘中的\"实习记\"文件夹彻底删除了，追毁莫及，粗心觉不是一件好的事情。 linux下回复ntfs盘下的文件不能用ext3grep，而使用debugfs命令实在很原始。 万幸所有记录文件的文件名都是：【实习记】2014-0 * *.txt 最后使用ntfsundelete + chown + chmod + sed 完美恢复刚才删除是所以TXT文件。 0、 sudo umount 该ntfs盘 1、 sudo apt-get install ntfs-3g 直接安装ntfsundelete是不行的，它被包含于ntfs-3g中，也包含于ntfsprogs(源中已弃用此包) 2、 sudo ntfsundelete /dev/sda3 -f -t 3m | grep 实习记 | awk '{print $1}' > ntfsundelete.txt 获取所有要恢复的文件的inode值，然后使用vi编辑使inode组成\"881,2341,234,…\"文本。 3m表示3个月以内生成并删除的，而不3个月内删除的意思。 3、 sudo ntfsundelete /dev/sda3 -d /home/wilson/tmp/ -u -i 881,2341,234,.... 恢复inode为881,2341,234等的文件。 5、 cd /home/wilson/tmp chown wilson:wilson * chmod a+r * for fn in *.txt; do sed -i 's/\\x00//g' $fn; done; 恢复后文件属主为root，权限为600, 需修复。 恢复后的文件一般末尾有多余的\\x00，使用sed也可以替换，一开始没想到。 6、 #done, enjoy it! 到恢复文件的位置去吧 参考 ［教学］在Ubuntu中恢复NTFS分区中被ubuntu误删除的文件（windows软件无法恢复的ubuntu中能恢复！ http://forum.ubuntu.org.cn/viewtopic.php?t=158497 Linux下恢复ntfs格式的盘上的误删文件 http://nyc1991.blog.51cto.com/6424159/1216592 Linux文件误删除恢复操作 http://jingyan.baidu.com/article/2f9b480d6c2bcd41cb6cc223.html","title":"【实习记】2014-09-26linux下恢复ntfs分区误删的文件","url":"2014/09/【实习记】2014-09-26linux下恢复ntfs分区误删的文件/","tags":"技术"},{"text":"最长公共子串问题分析 其实这是一个序贯决策问题，可以用动态规划来求解。我们采用一个二维矩阵来记录中间的结果。这个二维矩阵怎么构造呢？直接举个例子吧：\"bab\"和\"caba\"(当然我们现在一眼就可以看出来最长公共子串是\"ba\"或\"ab\") b a b c 0 0 0 a 0 1 0 b 1 0 1 a 0 1 0 我们看矩阵的斜对角线最长的那个就能找出最长公共子串。 不过在二维矩阵上找最长的由1组成的斜对角线也是件麻烦费时的事，下面改进：当要在矩阵是填1时让它等于其左上角元素加1。 b a b c 0 0 0 a 0 1 0 b 1 0 2 a 0 2 0 这样矩阵中的最大元素就是 最长公共子串的长度。 在构造这个二维矩阵的过程中由于得出矩阵的某一行后其上一行就没用了，所以实际上在程序中可以用一维数组来代替这个矩阵。 代码实践 根据以上算法 使用C语言实践了一下。 #include <stdlib.h> #include <stdio.h> #include <string.h> int comfix ( const char * stra , const char * strb ); int main ( void ){ const char * stra = \"hello world\" , * strb = \"malloc\" ; printf ( \"%s,%s: %d \\n \" , stra , strb , comfix ( stra , strb )); return 0 ; } int comfix ( const char * stra , const char * strb ){ /* * 变量第一字符 * c:char*, l:len * 变量第二字符 * s:small, l:large */ const char * cs = stra , * cl = strb ; int ret = 0 , la = strlen ( stra ), lb = strlen ( strb ), ls = la , ll = lb ; /* 如果不对，就调换呗 */ if ( lb < la ) cs = strb , ls = lb , cl = stra , ll = la ; /* 矩阵，只保存矩阵的一行即可动态之 */ int * pint = ( int * ) malloc (( ls + 1 ) * 4 ); memset ( pint , 0 , ( ls + 1 ) * 4 ); int i , j ; for ( i = 0 ; i < ll ; i ++ ){ /* 生成下一行，同时上一行内容被回收 */ for ( j = ls ; j > ret ; j -- ) if ( cl [ i ] == cs [ j ]) pint [ j ] = pint [ j - 1 ] + 1 ; /* 如果有更大就更新ret */ for ( j = ls ; j > ret ; j -- ) if ( pint [ j ] > ret ) ret = pint [ j ]; } return ret ; } 这种算法非常巧妙地化繁为简，有时换一个思路，就会扩然开朗！ 比较喜欢这种锻炼。 参考 研究了 求最长公共子串问题，顺便研究了字符串匹配 字符串匹配的Boyer-Moore算法 http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html 字符串匹配的KMP算法 http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html 动态规划算法之：最长公共子序列 & 最长公共子串（ LCS ） http://my.oschina.net/leejun2005/blog/117167","title":"【实习记】2014-08-29算法学习Boyer-Moore和最长公共子串（ LCS ）问题——阿里校招题","url":"2014/08/【实习记】2014-08-29算法学习Boyer-Moore和最长公共子串（LCS）问题——阿里校招题/","tags":"技术"},{"text":"前言 自学计算机技术，越到后面，越依赖ubuntu，以致于很多时候都是一开机就打开虚拟机上的ubuntu10.04，Linux已经变得越来越重要了。 操作 2014-04-17，ubuntu14.04(trusty)，长期支持版( LTS =long term support)，还记得那天也是我腾讯实行的2面。我知道等到时机了，果断装双系统！ 开始 用实验室那台ubuntu13.10直接升级，用了几个钟换来开机后一大堆的错误弹框，累觉不爱，说明直接升级是不行的，在此谨记！ 很不喜欢ubuntu后面自己的桌面。拿实验室的继续重装ubuntu-gnome版，还能接受，但却有些太求炫不求实的感觉。 萌生转kubuntu，feroda, mint, centos等的想法，差点转了mint，唯一觉得debin->ubuntu->mint这样子的飘着很难让人放心，比如你相信一个人99%，但很难相信他的孙辈。 搜索良久，纠结良久，看到开源新闻消息说Linus受不了gnome3的卖炫而投向xfce阵型。我便也跟风转xubuntu，转完后大喜，因为超过我理想期望很多。 xubuntu14.04优点 一、Olivier Fourdan开发，一个运行在各类Unix下的轻量级桌面环境。 二、仿win风格的界面，对双系统的人很好 三、超省资源，开机后htop显示198M已用内存 四、32Linux内核系统识别了4G的3.97G，win7只识别2.95G，让我惊喜 xubuntu14.04截图 改成windows风格桌面很容易 更多截图http:// www.douban.com/photos/album/132398060/","title":"笔记本系统转换Linux一个半月——xubuntu14.04截图纪念里程碑","url":"2014/07/笔记本系统转换Linux一个半月——xubuntu14.04截图纪念里程碑/","tags":"技术"},{"text":"时间：大三 上学期没有用微信内置浏览器而纯对话开发，坑了自己好一下。 下学期选错bottle框架，以为轻量好，谁知开发中什么都自己来很痛苦。 选对了框架django，终于在大三最后的个把月里写出了里程碑式的现在这个微信端，自己都感动到，作为我大三一年web开发的终结吧。 亮点1：自带后台管理 亮点2：后台权限管理 亮点3：微信回复规则设置去代码化，图形界面。 亮点4：一平台多网店 亮点5：图片自动缩略成200*300px大小（使用了七牛空间） 亮点6：gzip压缩，网络流量为原来33%左右。SAE中Gzip压缩设置 亮点7：保存接受的所以文本消息，记录永存！ 亮点8：购买者可查看历史订单，购买总额等。 亮点9：后台可查看用户下单总额，最近下单时间等等。 亮点10：商店信息，商品信息均在后台直接修改。 亮点11：平台创始人可强制商店下线。 技巧：微信规则不匹配时不能回复吗？不是，规则包含空字符总能匹配任意文本，请看下面的微信规则截图。 后台 选择botlle框架，自己写sql，便学边用，很痛苦的换了20天作出来了微信 第一版 。这版其实很简陋，但其给我的经验很重要。演示地址： 点击入口 。 抛弃bottle，选择django，后来证明我的选择是对的，虽然学习坡度比较大，但是其框架本身带来的效率和效益却是学习框架本身的好几倍。我喜欢它的自带后台管理，和后台权限管理，更喜欢它的ORM，省去很多sql的事情，比如sql语句编写，sql防注问题，sql迁移方便等等。这次用上了这三大功能，另外还巧用django的模板渲染实现微信回复功能，但这不是django特有。 微信已经实现了多店功能。这也是当初我为什么坚定选择django，因为django的一project多app的架构刚好契合这个一平台多店铺的想法。后来我学scrapy框架，发现也是一project多app，方便不少。同时说明一project多app是先进的，是趋势之一。 前台 我比较喜欢后端的开发，前端的我就修改已有好的前端代码，参考了微信公众号\"果然美\"，\"微果大爱\"，\"华农果满堂\"，\"微盟\"，\"乐外卖\"等前端设计。技术上使用html5+css3。 现在平台上有果色天香和澳洲红酒两个店铺 代码统计 使用linux shell统计 合理版 cat $(find . -name \" .py\" -or -name \" .yaml\" -or -name \"*.rst\" -or -name \"sell_detail.html\") | wc | sed \"1i static:\\nlines | words | bytes\" 纯净版 cat $(find . -path \"./guosetianxiang\" -prune -or -name \" .py\" -or -name \" .yaml\" -or -name \"*.rst\" -or -name \"sell_detail.html\") | wc | sed \"1i static:\\nlines | words | bytes\" 完全版 cat $(find . -name \" .py\" -or -name \" .yaml\" -or -name \" .rst\" -or -name \" .html\") | wc | sed \"1i static:\\nlines | words | bytes\" 前端展示：感谢前人成果！ =============================后台是亮点============================= 后台首页 微信回复规则，使用模板渲染自定义变量！ 功能代码： 微信用户 订单截图 看到这里，你是否也认为django是个好框架呢？ 在新浪云上运行得还好，不算慢，请那些嫌弃django臃肿庞大，速度慢的人，不要再误导他人，这就好像那些说python慢的人一样，我至今没有实践证明出过慢在哪。 django是python作者本身都很喜欢的框架，又是那么多商用网站的框架，经得其考验。 如果可以，当然希望你可以作出一个比django更好的框架，可是至少现在还不大可能。python的django和ruby的rails都得经过时间的考验。我相信 django 是经得住考验的，正如我相信python一样。 附上 增加微店步骤（澳洲红酒为例） 复制guosetianxiang 改名 aozhouwine 修改setting.py 安装app ‘aozhouwine' 访问/syncdb-online完成数据库同步 根app的url.py 加入两行: import aozhouwine ... url ( r '&#94;aozhouwine/' , include ( 'aozhouwine.urls' )), admin管理，weixinshop应用商店表中增加一条，并增加账户给商店所有者A，然后授权。 A在自己的应用商店信息表中增加一条记录，(token在此设置)。 微信开发者url: /aozhouwine/weixin/ token为之前设置的。 访问/aozhouwine/sync_shopinfo完成商店同步。 A增加消息，回复规则表中的记录。 A上架商品。 依然涉及少量代码操作，以及有一点繁琐。","title":"微信开发python+django两个月的成功经历，django是个好框架！","url":"2014/06/微信开发python+django两个月的成功经历，django是个好框架！/","tags":"技术"},{"text":"地点：华南理工大学大学城校区，为广州考点。 流程：网申3.X + 笔试4.12 + 一面4.15 + 二面4.17 + 三面4.19 + 签约4.25 前言 腾讯实习招聘笔试到拿到offer（软件工程师-研发反向），历时两星期，只算笔试到终面的话则是一星期，效率比阿里要好。 腾讯是我的处面，一路过来我没有夸张，只是平实的叙述我的故事，认真谨慎的答问。 我容易紧张，但幸好没有太紧张。 2014-3-18 网申（宣讲会在大学城太远了跳过～呵呵） ( 0 ) 准备： 1、寒假就开始准备，主要是重拾算法，发现没之前开始学编程那么难了。 2、寒假期间pythontip有个挑战python，做72题后排第三名。挑战最长回文，最长上升子串等算法题，综合能力提升。 3、看完《编程珠玑》和《编程之美》。 4、google面经，做往年题练手。 5、Linux下gcc+vim实践7大经典排序算法（这个效用较高）。 6、精心准备的简历，3月8号就做了1.0版，后修改不下10次，要求尽量简洁美观。 2014-4-12 周六 14:30 - 16:00 笔试 ×—× 心情： 1、收到信息，知道阿里笔试被鄙视了。 2、三个项目在手（都是不感冒的web项目-_-）。 3、报大创，课程作业，等等等等……，一个字，累！ 内容： 1、20不定选择（一半把握）填空5题（4题把握）附加2题（会后一题）。 2、C语言C++，操作系统，网络，数据库，经典算法，数学IQ题加起来占80%以上吧。 感受： 做的不上不下，做得快，但修改得多。交卷到了，还把一题对的改错了，囧。 后记： 1、打击过后的我只敢保守地估计，谨慎地乐观，默默地独自回校。 2、心中感觉一些轻松，一些冷漠，像我本是局外人。 2014-4-15 周二 10:00 - 11:00 一面 单面 T_T 过程： 1、面试官是位大叔，讲话少，自我介绍时\"嗯\"了很多，有时闭着眼在听。 2、以C语言的宏的作用是什么开头，问了我很多广泛问题。 3、幸好C语言，C++我都记得，答取结构偏移址，宏用途，宏在C与C++之间重要性的区别还答得上。 4、但是问到数据库时瘪了，索引什么的更是一知半解（本来至少应该摆个二分法），大数据找重也不好的。最记得让我描述http协议，我不知从何说起，各点都提一提。 5、我尝试过避开这些，引导到Linux上，无效。越到后面我就越觉得机会小。 6、最后让我一边去写strcpy，我用了assert，并加上测试，还应此知道缺const。 感受： 1、没玩过游戏，但我觉得一个初出茅庐的0级玩家被40级玩家虐的时候也是这样吧。 2、我知道简单问题考细节，幸好这时刻这点我做得不错。 3、从专业名看到话面试官还是以为我技术出身，幸好后来我答题时明确说明了。 4、答题是不坚定，没自信，这是我的弱点。 后记： 1、阿里铩羽而归后的又一次打击，本来觉得我应该无后文，继续华为，小米，百度实习关注填表。 2、我后来惊喜收到二面短信，可能和我很重实践，Linux，github，操作系统代码有关。 3、当时答得不太好的如socket，进程通信，netstat -ptln我都马上复习了，为了别的面试。结果让我在二面表现更好。 2014-4-17 周四 8:30 - 9:00 二面 单面 - 过程： 1、自我介绍8分钟，以Ubuntu14.04正式版发布这开源新闻开始，还是那篇讲学习经历和项目的自我介绍。最浓缩就是：windows->Linux->Python。期间他有打断问我具体细节，我都详细作答了。 2、他问我有没有纸，我说8太早了工作人员让我直接去房间。面试官有些失望的样子，我在暗想，草稿纸算法题目必需的，这是对我故意的眷顾，会不会是上个面试官的特意安排吗？不知道，也许就是偶然的幸运。 3、面试问题问细节比较多，问的深度和一面挺像，所以感觉没什么压力。 4、面试官过程中礼貌而中肯地多次说\" OK \"，最后说\" OK ，现在你有几分钟时间问我问题。\"。 5、我问了腾讯与开源的一个烟雾弹问题，还问微信未来是否会像易迅一样开微店，——干脆利三个字\"有可能\"——意料之中，然后我们最后握手告别。 感受： 1、一开始面试官就看出我的紧张，他笑着指出了。还好之后整个过程都比较轻松。 3、能到这里其实我是满足的，不管怎样。 4、我在最后的一瞬间感觉到了一种肯定，那握手和神情。但我依然很保守地乐观。 后记： 1、出来后心情，做番201去星海过程中观赏者大学城。 2、回去过程在回想面试，面试官给我感觉挺好的，他当时穿了米黄色衬衫，中等身高有点胖，印象中头发有点蓬松，和脸相搭。 3、出来后直到回学校，觉得我是幸运的。 2014-04-19 周六 15:22 - 15:37 三面 单面 ( w ) 感受： 1、微信状态变成HR面是很开心，因为有HR不怎么刷技术岗之说。同时感概些许，也许就在前面了，但我告诫自己绝不能倒在这关。 2、告诉舍友我到HR时，他们都为我高兴了，我们笔试时几乎全宿舍都去了（光说动员，6人中5人去了-_-）。 3、紧张而兴奋，期待而舒畅的等待着。 过程： 1、面试官还是男性，还是那份简历，还是华工大学城中心酒店。 2、15分钟，自我介绍，和HR聊天，我不太健谈，不过还算一个愉快的过程。 3、最后让问问题，查笔试成绩没成，问可能去向问到了。 后记： 2014-04-25，offer终签成，一件好事来了。哈哈。 面试经历总记： 我是个粗心人! 1、14号晚收到一面通知在15好，而我以为当天是13号，睡前发现这个\" BUG \"，起来准备到2点才睡，第二天7点起床。 2、微信查进度jg这两字符总漏了，\"修复\"后得到第一个回复是处在到HR面中。我的色弱也许占部分原因。 3、我是个不懂得察言观色，后知后觉型小傻呆。所以无法把握自己的面试，最近有看《Lie To Me》，对没能运用这知识有点遗憾。 我是个认真务实好学的人！ 1、自学C/C++，java，html/css/js，kenerl，Linux，Shell，Python等等。 2、为应聘做了很多的准备，寒假就开始，有针对性的练习算法，多次锤炼简历，2小时准备的自我介绍586字。 3、不懂时就问，敢问，问得很多，感觉有时被鄙视了（我想懂得范畴以外，我都是白痴）。 4、边学边实践，边看书籍，边写敲键盘。因此记得还算牢固，学习速度还可以。 5、不是到用的时候才有，而是到用的时候来总结。所以不会被问到哑口无言。 经验总结 后来我猜，自学能力，多种语言，C/C++功底，Linux，blog，github，项目，这些是决定我能留下来的组成部分。 其他： 我是谁？ 我是大学开始自学技术的商科学生 1、技术的我：一个Linux与Python爱好者，关注开源和C/C++，使用Vim编辑器，喜欢Shell下工作。（技术宅？不是的，希望像耗子大叔一样。） 2、学生的我：一个商科11届大学生，来自广东文科老二，理科老三的（按高考分数线的话）211暨南大学( JNU )。大学以自学副业为主，暂没获得过奖学金。 3、生活的我：爱好比较广泛（童心OR好奇心……随便吧-_-）；历史(春秋迷)，登山(户外迷)，排球还不错，听电台，LoveQ。听电台的90后不多了，我就是其中之一，嘻！ 关于 关于简历。word是彩版，但印的是黑白，怕面试官认为华而不实。（-_-,也许心疼成本才是真，囧）。 关于招聘。搜\"算法+数据结构\"可能还不如你搜\"笔试面经\"获得的结果好，强，全。 关于经验。腾讯2013暑期实习生招聘经历分享对我很有帮助，作者是同校同乡的上一届师兄。这后来成为我写本文的原因一部分。 关于暨大。个人认为腾讯与暨大之间存在信息不对称问题，结果导致暨大实习生比例过低。前几年均如此。当然也不排除暨大自身问题啦。 关于腾讯。我明白获得实习offer只是开始，但是腾讯给出的资薪待遇挺不错的，至少对于我，呵呵。 关于自学。图书馆 -> google -> 独立博客 -> rss鲜果 -> 开源。遇见Linux是转哲点。 我用到过的好资源共享： 别的程序员是怎么读你的简历的 http://coolshell.cn/articles/1695.html 找工作笔试面试那些事儿（系列） http://blog.csdn.net/han_xiaoyang/article/category/1664765 白话经典算法 http://blog.csdn.net/morewindows/article/details/17488865 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦 http://blog.csdn.net/v_july_v/article/details/6543438 2014年计算机求职总结–准备篇 http://blog.csdn.net/luckyxiaoqiang/article/details/13000431 《程序员编程艺术 — 面试和算法心得》 https://github.com/julycoding/The-Art-Of-Programming-By-July 《剑指Offer——名企面试官精讲典型编程题》博客 http://zhedahht.blog.163.com/","title":"腾讯2014实习面经——记一个非计算机学生的首次面试","url":"2014/04/腾讯2014实习面经——记一个非计算机学生的首次面试/","tags":"技术"},{"text":"前言 学习python，官方版本其实足够了。但是如果追求更好的开发体验，耐得住不厌其烦地折腾。那么我可以负责任的告诉你：IPython是我认为的唯一显著好于原版python的工具。 整理了《Python 二三事》： http://pre-sence.com/archives/python-intro 《Python 四五事》： http://pre-sence.com/archives/python-misc 并加入安装IPython部分。 写这篇随笔的原因是：忽然醒悟之前我安装IPython折腾许久不成功可能是我未能想起pip或easy_install这两个python的上帝工具。参考：Python包管理工具pip与easy_install 个人经验总结：IPython，是学习python的利器，是让Python显得友好十倍的外套，是我唯一的强烈推荐。 安装IPython 任何Linux发行版对编程者都十分友好： Ubuntu为例: sudo apt-get install ipython windows环境: 1、下载[ez_setup.py][ez_setup.py] ，右击左边链接，另存为，使用 python ez_setup.py 运行，或直接双击。 2、步骤1成功后，cmd下输入命令 easy_install -h 可以测试，正常反应说明已经可以使用easy_install了。 3、cmd下输入 easy_install pip 安装pip，这是因为pip正是easy_install的下一代，比easy_install好用。 4、步骤3成功后， pip install ipython 。 5、如果步骤4不行，退一步，使用 easy_install ipython 安装。 运行IPython cmd提示符下，输入ipython运行就可以使用除了原python外，IPython多出来的贴心的\"I\"了。 退出IPython 与python一样也是输入 exit Python实用技巧： 1、关于 \"_\" 字符使用 在 Python shell 下 _ 总是被赋予之前最后一个表达式的值（注：@pythonwood）。这里看个例子应该就能清楚： >>> import string >>> string . letters 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' >>> print _ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ >>> 2014 2014 >>> v = _ >>> v 2014 举个实际的例子，比如你在调试时读文件的时候直接进行 f.read() ，你看了看发现输出结果很有意思，想要对它进行进一步处理，但发现读的时候忘记赋值了。以往你只能叹叹气重新开文件再读一次，现在你只要执行 result = _，把 _ 附到另外一个变量就可以了。 2、python -m 相信很多人应该用过这个东西，Python 很多标准库都提供这样的调用方式来实现一些简单的命令行功能。Python 3 现在自带 pip。比如我们想使用 Python 3 的 pip 来安装别的库，我们可以这样： py -3 -m pip install bottle 跟你预料的一样，这样就可以了。当然你可以用个 .bat 文件来把这些包裹起来并放在 Path 上，一个简单的例子，把下面的内容写到一个叫 pip3.bat 的文件里: @echo off py -3 -m pip %* 并放到 Path 上，就可以方便调用了。其中 %* 负责传递所有的命令行参数。 实际上 python -m 可以用的东西还真的挺多，这里给出一个不完全的列表： ###################################################### # 最强功能 ###################################################### # 局域网共享，宿舍中任意一台笔记本都可以瞬间变身web资源共享服务器 # 命令ipconfig可以看到局域网ip地址，一般是192，172这些开头的。 # 使用本机80端口，可任意设置。只共享当前运行目录。 # python -m SimpleHTTPServer 80 # # 本机任意浏览器输入 http://localhost 或 http://127.0.0.1 可以访问。 # (80端口浏览器默认的，不需输入)甚至在地址栏直接输入localhost即可。 # 局域网，（宿舍）任意电脑输入上面所说192或172等开头的IP地址即可访问。 ###################################################### # 缩进输出 JSON echo {\"hey\" : \"kid\"} | python -m json.tool # 简单的执行时间测量 python -m timeit [ix*ix for ix in range(100)] # 简单的 Profiling python -m cProfile myscript.py # 比较两个文件夹的区别 python -m filecmp path/to/a path/to/b # base64 转换 echo foo bar | python -m base64 # 调用默认浏览器打开一个新标签页 python -m webbrowser -t http://google.com # 生成程序文档 python -m pydoc myscript.py # 类似 nose 的自动搜索 unittest python -m unittest discover # 调用 pdb 执行代码 python -m pdb myscript.py IPython实用技巧： 1、Tab自动补全，一种是简单的关键字补全，另外一种是对象的方法和属性补全。 作为例子，我们先引入 sys 模块，之后再输入 sys. (注意有个点)，此时按下 tab 键，IPython 会列出所有 sys 模块下的方法和属性。 接着上面的例子，我们输入 sys?，这样会显示出 sys 模块的 docstring及相关信息。很多时候这个也是很方便的功能。 2、IPython 还有强大之处很大部分还体现在它的 magic function 中。它是指的在 IPython 环境下执行以 % 开头的一些命令来对 IPython 进行一些设定或者执行某些功能。在 IPython 中输入 %lsmagic 就能列出所有的 magic functions。在这里简单介绍下几个比较有意思的，你也可以自己通过查看文档来找找有哪些你特别用的到得。 之前看到能用 ? 来查询函数的文档，对于 magic function 也是如此。比如 %run ? 。 ! cd .. 在命令前面加上 ! 则它会被作为命令行命令执行，这样你就不用退出 IPython 来进行命令行操作。 %run foo . py 在当前环境下直接执行 foo . py ，效果跟命令行下调用 ipython foo . py 相同。 %time foo . bar () 跟 timeit decorator 作用相同，进行简单的 profile 。 %hist 能显示之前输入过的命令的历史，同时你可以用 In [ < linenumber > ] 来访问之前的命令。比如 %exec In [ 10 ] 就能执行列表中第十行。 %rep 类似上面的 _ 变量，但是是以字串的形式返回 最后，如果 %automagic 是打开的状态的话，所有 magic function 不需要在前面加 % 就能正确调用。 在当前 IPython 版本中还有一个由于安全原因没有默认引入的 %autoreload，它的作用是在可以自动重新载入你调用的函数，以及其相关模块。接触过 django 的同学对这个应该比较熟悉，在 IPython 中的效果就是，当你在调试一个一直在反复改动的函数时，你可以开启这个功能保证每次调用都会重新读取最新的版本，让你在源码中的改动马上生效。在 IPython 中执行 import ipy_autoreload %% autoreload 2 这样 IPython 会对所有的模块都进行 autoreload。你可以通过执行 %autoreload? 来查询它的文档来进行进一步设定。如果你希望 IPython 每次启动自动载入次功能，那么可以通过配置 ipythonrc (在 Windows 下可以在 C:\\Users\\ _ipython\\ipythonrc.ini 找到) 来进行相关设置。 3、还有一个很神奇的功能。如果你的程序是由命令行开始执行的，即在命令行下输入 python foo.py（大部分 Python 程序都是），那么你还可以利用 IPython 在你的程序任意地方进行断点调试！ 在你程序中任意地方，加入如下语句： from IPython.Shell import IPShellEmbed IPShellEmbed ([])() 注意：最近 IPython 发布了 0.11 版本，各方面变化都非常大， API 也经过了重新设计。如果你使用的是 0.11 那么上面两行对应的是这样的: from IPython import embed embed () 再和平常一样运行你的程序，你会发现在程序运行到插入语句的地方时，会转到 IPython 环境下。你可以试试运行些指令，就会发现此刻 IPython 的环境就是在程序的那个位置。你可以逐个浏览当前状态下的各个变量，调用各种函数，输出你感兴趣的值来帮助调试。之后你可以照常退出 IPython，然后程序会继续运行下去，自然地你在当时 IPython 下执行的语句也会对程序接下来的运行造成影响。 这个方法我实在 这里 看到的。想象一下，这样做就像让高速运转的程序暂停下来，你再对运行中的程序进行检查和修改，之后再让他继续运行下去。这里举一个例子，比如编写网页 bot ，你在每取回一个页面后你都得看看它的内容，再尝试如何处理他获得下一个页面的地址。运用这个技巧，你可以在取回页面后让程序中断，再那里实验各种处理方 法，在找到正确的处理方式后写回到你的代码中，再进行下一步。这种工作流程只有像 Python 这种动态语言才可以做到。 4、一个实际的例子 这里以一个简单的例子来讲解一下是怎样的一个情况。我们要写一个可以将简单的数据表达式，类似 1 + (2 - 3) * 456 解析成树的 Pratt Parser。首先我们需要一个 lexer 把每个 token 解析出来，那么最开始的代码就是： # simple math expression parser def lexer(s): '''token generator, yields a list of tokens''' yield s if __name__ == '__main__': for token in lexer(\"1 + (2 - 3) * 456\"): print token 明显这个没有任何意义，但现在程序已经有足够的东西能够跑起来。我们把这个程序存为 expr.py，开启一个命令行窗口，运行 ipython 然后像这样执行它： $ ipython IPython 0 .13.1 -- An enhanced Interactive Python. ? -> Introduction and overview of IPython ' s features. ... In [ 1 ] : run expr.py 1 + ( 2 - 3 ) * 456 在 IPython 里面用 run 跑的好处有很多，首先是你在程序执行完毕后整个程序的状态，比如最后全局变量的值，你写的函数这些你都是可以随便执行的！同样的你可以在 IPython 里面保存一些用来测试的常量，每次用 run 跑的话新的程序会被重新载入，你可以这样方便的测试每个函数，有一个非常动态的环境来调试你的程序： In [2]: print token # 注意这里 token 就是 __main__ 里面的那个 token 的值 1 + (2 - 3) * 456 In [3]: print list(lexer('1+2+3')) # 可以运行你写的函数 ['1+2+3'] 然后按照之前的想法，我们尝试把这个 lexer 写出来。在这个过程中，IPython 可以用来查看函数的文档，测试如何调用某些函数，看看返回值是什么样子等等，还是跟上面的说的一样，我们有一个动态的环境可以真真正正的执行程序，你可以 在把代码写到你珍贵的主程序之前就有机会运行它，这样你可以更确认你的代码能正常工作： In [4]: s = \"foo\" # 忘记判断字符串是数字的函数的名字了，用一个字符串试试看 In [5]: s.is # 开头大概是 is，这里按下 tab 键 IPython 会帮我们补全 s.isalnum s.isalpha s.isdigit s.islower s.isspace s.istitle In [6]: s.isdigit? # 结果是 isdigit，在表达式后加上问号并回车查看文档 Type: builtin_function_or_method String Form:<built-in method isdigit of str object at 0x1264f08> Docstring: S.isdigit() -> bool Return True if all characters in S are digits and there is at least one character in S, False otherwise. In [8]: s.isdigit() # 调用试试看 Out[8]: False In [9]: 'f' in 'foo' # 试试字符串能不能用 in 来判断 Out[9]: True 确认了各个步骤以后，我们把 lexer 的代码填起来。我们为了节省纵向的空间我们把很多东西写在一行里面： # simple math expression parser ( broken lexer ) def lexer ( s ): '''token generator''' ix = 0 while ix < len ( s ): if s [ ix ] . isspace (): ix += 1 if s [ ix ] in \"+-*/()\" : yield s [ ix ] ; ix += 1 if s [ ix ] . isdigit (): jx = ix + 1 while jx < len ( s ) and s [ jx ] . isdigit (): jx += 1 yield s [ ix : jx ] ; ix = jx else : raise Exception ( \"invalid char at %d: '%s'\" % ( ix , s [ ix ] )) yield \"\" if __name__ == '__main__' : print list ( lexer ( \"1 + (2 - 3) * 456\" )) 看起来不错，我们还是在 IPython 里执行试试，结果发现程序抛出了一个异常: In [ 6 ] : run expr . py ------------------------------------------------------------------ Exception Traceback ( most recent call last ) py / expr . py in < module >() 18 19 if __name__ == '__main__' : --- > 20 print list ( lexer ( \"1 + (2 - 3) * 456\" )) py / expr . py in lexer ( s ) 13 yield s [ ix : jx ] ; ix = jx 14 else : --- > 15 raise Exception ( \"invalid character at ...)) 16 yield \" \" 17 Exception : invalid character at 3 : ' ' 嗯？好像程序里已经处理了空格的情况。怎么会这样？不知道你碰到异常的时候一般都怎么办。你可能会选择到处添加 print，用 IDE 断点调试。其实这种情况用 pdb 是很明智的选择，在 IPython 里我们可以非常轻松的使用它。 In [13]: pdb # 开启 pdb ，这样在异常的时候我们会自动的 break 到异常处 Automatic pdb calling has been turned ON In [14]: run expr.py ----------------------------------------------------------------- Exception: invalid character at 3: ' ' > py/expr.py(15)lexer() 14 else: ---> 15 raise Exception(\"invalid char at ...)) 16 yield \"\" ipdb> print ix # 这里我们可以执行任何 Python 的代码 3 ipdb> whatis ix # 也可以用 pdb 提供的命令，输入 help 可以查看所有命令 <type 'int'> 通过方便的调试和仔细检查代码，我们发现是没有正确的使用 elif 造成了问题！（我知道这个过程不是太符合情理…）。把代码里的后面的几个 if 都换成 elif 以后我们发现结果基本上是对的了。我们可以马上再跑几个类似的例子，确认不同的输入是否都有比较好的结果： In [18]: run expr.py # 这次差不多对了，我们可以试试几个别的例子 ['1', '+', '(', '2', '-', '3', ')', '*', '456', ''] In [19]: print list(lexer(\"1*123*87-2*5\")) ['1', '*', '123', '*', '87', '-', '2', '*', '5', ''] # 跟在 shell 里面一样，你可以用上下来选取之前的记录，然后简单的修改再重新执行。 # 记得每次 run 后你的函数都是最新版本，你可以很简单的用重复的数据来测试你的函数 # IPython 甚至还实现了 Ctrl+R！自己试试看吧 In [19]: print list(lexer(\"1 + two\")) Exception: invalid character at 2: 't'... 在一段痛苦的调试之后，我们最终把程序写 出来 了。很遗憾程序超出了我预计的长度，就不贴在这里了。后面部分的开发过程跟前面基本还是一样，总结起来就是： 保持你的程序是一个可以运行并且有意义的状态，尽可能频繁的运行。 在 IPython 里查看文档，尝试小的程序片段，测试些你不确定的做法，确定之后再把东西添加到你的代码里。 用不同的参数在 IPython 里测试你正在编写的函数/class。 当遇到问题的时候，先简单的用 pdb 在异常处 break，十有八九都能有些头绪。 额外的注意事项 这里举的例子是你所有的开发都是在单个 .py 文件里的。现实生活中你很有可能会横跨几个文件一起修改。请务必注意，在 IPython 里你每次 run 的时候只有被 run 的那个文件里的东西会是最后修改的版本，其 import 的东西如果在期间被修改是不会反应出来的。 这个的原理就跟你在 Python shell 里在修改前修改后重复 import 某个模块不会有作用是一样的，Python 神奇的 import 机制不会去追踪其他模块的修改。你可以手动用 reload 函数来重新载入，你也可以使用 IPython 的 autoreload 功能来让你忽略这个问题。个人来说我没怎么用过这个功能，IPython 没有默认开启它可能也是有些顾虑，请自己评估看看。 另外你应该已经注意到，run 的效果基本上就是把你的代码拷贝进 IPython 里执行一遍。对于没有 main 的文件，你也可以 run，这样里面定义的函数和 class 就会反映出你的更改。","title":"IPython，让Python显得友好十倍的外套——windowsXP、Win7安装详解","url":"2014/04/IPython，让Python显得友好十倍的外套——windowsXP、Win7安装详解/","tags":"技术"},{"text":"选课是个问题，为了选课，便有了以下的故事。 选课需求与背景 最开始，萌生想法于2013年7月。 接着网上了解了chrome的结构知识，却发现例子是假的。 幸好有之前师兄的一个同功能插件开源，但代码写得很乱，我喜欢逻辑清楚，结构优雅的代码。终于决定重写一个。 继续学习chrome,jQuery知识，遇到问题主要找百度谷歌，发现谷歌搜索比百度强多！而且，本博3个月了都还没被百度收录到！ 关键时间是从2013年9月2日到9月6日，工作时间安排非常严重，以致最后生病了。 收益是： 一、这个小小的项目，我经历了功能导向的项目开发的全过程。 二、获得了从零到有的chrome开发实践经验。 三、jQuery从零到有，用得其所，学有所成，不是光学理论的易忘型。 四、增强了我的学习信心，开阔了我的视野。 坏处是： 1、过程累，有压力，睡眠不足。明白程序员是不好当的。 2、完成项目后两三天，病倒了，休息了半个月，特别是中秋节几天废了！ 总结： a、学习他人代码是成为高手的捷径。以前我很不愿意读代码。要想看得远，还可以站在巨人的肩膀上。 b、的确有针对性的问题的搜索学习方式是一种无上的学习方式！ 附参考： 好书推荐：《锋利的jQuery》 chrome插件入门第一步： Chrome插件（Extensions）开发攻略 >>> http://www.cnblogs.com/guogangj/p/3235703.html Chrome 插件开发： >>> http://nottiansyf.iteye.com/blog/546612 Chrome插件开发之一: 搭建基本结构 >>> http://blog.csdn.net/ligaoyang/article/details/6065328 chrome插件编写中需要了解的几个概念和一些方法 >>> http://www.itzhai.com/chrome-plug-in-writers-need-to-understand-a-few-concepts-and-some-of-the-ways.html (有一系列的讲解) 使用chrome查看http请求 >>> http://www.whoslab.me/blog/?p=416 chrome 查看網頁post參數方法 >>> http://itgroup.blueshop.com.tw/superpapa/notebook?n=convew&i=405927 chrome深入： Chrome插件开发中的消息传递 >>> http://www.yuanlairc.com/program/chromex.html Chrome扩展开发常见问题汇总 >>> http://www.cnblogs.com/slmk/archive/2012/11/16/2772985.html 这段时间正是12306抢票时间刚过，神器不过浮云，如果你看透了它。JNU的。","title":"校园选课项目：一个名字叫jumper的chrome插件的诞生记","url":"2014/04/校园选课项目：一个名字叫jumper的chrome插件的诞生记/","tags":"生活"},{"text":"2014年2月中旬，我上升到挑战python英雄榜第3名。这是我寒假修炼算法的成果之一。来一下总结吧！ Linux的创始人Linus Torvalds在一次演讲中有一段涉及\"什么才是优秀程序员\"的话： \"烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。\" 由这句话的启发开始，加上我越来越觉得自己编程能力不足，码代码经常要重构，逻辑思维不过细腻谨慎。正是过于关注代码，完成率所致。我已经学过C/C++/nasm/java/python/html/js/jq/shell等等语言，对计算机世界的工作原理有比较好的认识，但代码能力一直上不去。我想算法，就是我的瓶颈。于是有了以下故事。 第一阶段 寒假开始，我便在项目工作之余扫pythontip上的题。十几天里，有时一天7、8道题，有时2、3题，我的排名慢慢从第N页到第4页到第2页，让后到第1页。 当我扫完101题后，我成功了42题，刚好排在第一页最后一名。然后我休息了一下，继续有成功几题。这大概就是我的无算法时代极限了。 第二阶段 我网搜博客，算法，学习排序。好来买了《编程珠玑》和《编程之美》，边看边攻克pyhtontip上的题目。 在PythonTip 上的一些水题这博客中学习了很多，尤其是看到问题一句话就解决时，恍然大悟。 1、有很多利用lambda, reduce, map, zip, 列表分片/解析, sum, max, min, divmod, round, hex/oct/bin; set,list,dict; 一句话解决的。这是我认为python强大原因，非常好用。 2、关于二进制‘1'的处理是非常妙的，这些题往往诠释了计算机较人类思维不同的特性，以及如何能让程序员思考得更\"计算机\"一些。在《编程之美》，上面提到的博客中都有提到。 3、独立思考，让后比较，我获得更多。在最大连续子序列，最大非连续子序列，最长回文子字符串中，我收获很经典的算法。同时还想出来与Manacher算法一拼的做法。 L = '#' . join ( list ( L )) # len is odd now ! l = len ( L ) o , r = 0 , 0 # 圆心，半径 ( 不计圆心 ) for i in range ( 1 , l ) : if i + r < l and L [ i - r : i ] == L [ i + r : i : - 1 ] : # 移到:最右方便来计算 o , r = i , r while i + r + 1 < l and L [ i - r - 1 ] == L [ i + r + 1 ] : r += 1 # print L [ o - r : o + r + 1 ] L1 = L [ o - r : o + r + 1 ] t1 , t2 = L1 [ :: 2 ], L1 [ 1 :: 2 ] print t1 if any ( i ! ='#' for i in t1 ) else t2 3月13日的 格式优化版： L = '#' . join ( L ) L = '#' + L +'#' # 因为这句，末尾print语句统一了。 o , r = 0 , 0 l = len ( L ) for i in xrange ( l ) : if i + r >= l : break if L [ i - r : i ] == L [ i + r : i : - 1 ] : o = i j = r + 1 # 尝试加一 while o - j >= 0 and o + j < l and L [ o - j ] == L [ o + j ] : j += 1 r = j - 1 print L [ o - r + 1 :o + r : 2 ] 又经过10多天，我又扫完一遍题，这次我以72题的成绩排在GodIsCoding和YOSHINO之后第三名。 总结： 做完之后，我的感觉是，python是很美很简单语言，如其名。 生活题外话： 没能及时报考C语言二级，非常遗憾，英语六级不知道报呢还是不报好。","title":"寒假挑战PythonTip（一人一python）总结——算法是程序的灵魂，程序员的心法","url":"2014/02/寒假挑战PythonTip（一人一python）总结——算法是程序的灵魂，程序员的心法/","tags":"技术"},{"text":"问题： chrome 升级到高版本，切换标签后点击，滚轮都没反应，假死不动。F12呼出控制台来开发时更让人揪心。(大概chrome 25更高) 原因： 我的电脑是:集显+512M独显，可切换的。这种配置完全是高不成，底不就！一点都不好，chrome 调用底层显卡驱动会出错。Firefox原因一样。如果只有一张显卡，无论集显独显，应该都无上述问题。 问题原因的关键字：硬件，兼容，显卡，驱动。 解决： 一、调整窗口大小(小白都会招) 触发窗口重绘，必唤醒显卡/驱动再工作。缺点是每次假死都要做。 二、设置参数 1、输入栏输入：chrome://flags，确定，找GPU加速（在前几项中），停用之。 2、输入栏输入：chrome://plugins，确定，如果flash插件有两个（显示详细），禁用第二个。 三、换Firefox，Firefox菜单->选项->高级，取消\"硬件加速\"的勾选。 这个是最好的方法，如果你和我一样已经忍无可忍。 忍受chrome问题1年半，最终导致我尝试Firefox，从此一发不可收拾。(纯粹的)开源软件就是强，开源社区总有惊喜！ 试过才知，firefox的web控制台更美更好看，可比chrome。 题外话： 我还发现了 Clementine 这开源音乐播放器。播放功能很强。 推荐的开源软件列表：firefox,smplayer,clementine,gimp,gvim,gcc,filezilla,nasm,python,git 最近在学linux脚本，jQuery,Pyhon。如gred,sed,awk文本处理，wget,curl,lynx(tcpdump,ngrep)网络工具。jQuery写前端。python做微信开发，爬微博。","title":"谷歌浏览器chrome假死卡死无反应,火狐firefox闪黑格子的解决办法（显卡、驱动兼容问题）","url":"2014/02/谷歌浏览器chrome假死卡死无反应,火狐firefox闪黑格子的解决办法（显卡、驱动兼容问题）/","tags":"技术"},{"text":"Emacs本来就比较臃肿，麻烦。当我发现Vim键盘图时，我就渐渐转向Vim，追随Unix/Linux哲学去了。。 我用了Emacs三个月，因为它的学习曲线没Vim陡，这点吸引了，我使用Linux才7、8个月，不明白Vim的简即是美，反而觉得是拒人千里(这点真和人一样)。 于是反思自己，后来转向Vim，今天把Emacs卸载了。 但是慢慢觉得Emacs有以下缺点： 命令至少双键同按，结果就是必须双手同时使用。 真的对末尾指不友好，不是Ctrl就是Alt，有人趣说恨不得配个脚踏板。 体积大，占资源多，反应相对慢。 相反，渐渐发现Vim的优点很多： 简即是美，单键命令，夸张说可以腾出一只手来。 99.9%的把握，是Linux就有Vim。 对Linux其它命令sed,tr等有天生的相关性，这就好比微软产品之间的连通性。 体积小，反应快。 命令行使用。 vim的windows版兼容性好。兼容对txt的操作Ctrl+S等。 符合Unix/Linux体系的根本思想，就是它的哲学。 最后一点，越学越有趣，自己发现组合。这就好像使用HTML标记来写网页一样，设计者将最大的发挥空间给了你。 再来讨论下：神之编辑器 VS 编辑器之神 编辑器之神，首先强调是编辑器，而且是其中的神！ 神之编辑器，神在前，编辑器也是其中的功能。(也译：神一样的编辑器，神的编辑器) Unix/Linux的设计哲学：做一件事，并做好一件事。 Emacs虽然强大，但它在Linux多少违反了其它大多Linux软件所遵守的约定，显得例外，特别不一样。 Emacs存在并兴盛说明它有价值，我并不是抹黑它。而是对于追求真正的纯正的Linux思想的人，可能容不下一点突兀。 我不会吃回头草。 参考资料：Vim vs Emacs http://blog.sina.com.cn/s/blog_8d1e632101018uyg.html 题外话：我写完后google了一下，搜索site: http://www.cnblogs.com/weishun ，本文赫然在最后一页最后一栏！","title":"我用Emacs，后来转向Vim——Vim学习之Vim键盘图（绝对值得珍藏）","url":"2013/12/我用Emacs，后来转向Vim——Vim学习之Vim键盘图（绝对值得珍藏）/","tags":"技术"},{"text":"虽然校园App是个我认为的绝对的好主意，但最近有个也不错的营销+开发的模式出现：微信平台+固定域名服务器。 微信公众平台的运行模式不外两个: 一、机器人模式或称转发模式，将说话内容转发到服务器上完成，拿服务器的回复再一次转发，就完成一次问答谈话。 二、人控模式，一个自然人登陆公众平台上，能直接接触到所有关注者，与之交互，这一定也是最累的。 微信公众平台若是服务号，用来做微网站，省去了登录认证过程。但说白了就是微信定制版的微网站。这我一学期后才搞懂，如果早些弄懂就不会做那么多无用功。 微信公众平台须有正面头像+身份证的照片来实名认证，非常严格。顺便一说，微信公众平台官方说法是偏支持大企而非个人。 服务器(准确的说只是一个引擎)有新浪云SAE，百度云BAE，阿里云AAE。 SAE最早，但使用云豆消费，注册只送500个。到现在，BAE允许创建10个应用而不用实名认证，SAE是需实名认证的。还有BAE比SAE强的就是支持git，虽然两者都支持svn，非常合时，刚好我学习git中，我果断选择BAE。云上建的每个应用可有20个版本，但任一个版都可以并且唯一上线。 AAE (阿里云)一直不支持python，很让人失望。 第一阶段：入门——轻轻走过飘过。 下面是用数天时间借鉴前人成果Kingson的《 一个用Python和Bottle实现基于微信公众平台API和SAE查询豆瓣电影的简单应用 》开发的。 这个例子非常适合在用Python的开发人员。经过一番狠狠的折腾，我还弄懂了其它问题：云的概念、OAuth、token、微信API调用，网站API调用、python等，百度谷歌都会有答案。 还有很多像微信API通信认证(话说竞然用xml而不用json通信，不过这是取舍问题，无可厚非)，python web框架，git对接云服务器……用了我许多时间。过程曲折复杂，看起来只是转移一下云平台，但实名认证，开发者域名的认证等浪费了我很多时间，因为没经验，很多各种问题都撞上了，尤其是我这种粗心大意，心眼碗粗的人，整个过程实在不算顺利，但我相信别人都会比我顺利，因为我连最低级的错都犯了。不多说，贴上关键代码代码。 下载地址： http://pan.baidu.com/s/1d1g3l 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 #! /usr/bin/env python # coding=utf-8 __author__ = 'jszhou' from bottle import * import hashlib import xml.etree.ElementTree as ET import urllib2 # import requests import json app = Bottle () \"\"\" Change Log: 03-04--03-08 完成微信API+Python自动回复代码雏形，可以通过电影ID查询电影信息，以Text形式返回给用户电影 Title和电影summary # 03-11 完成通过电影名称查询并返回图文格式的数据 # 03-13 1.增加给新关注的用户自动返回\"欢迎关注豆瓣电影，输入电影名称即可快速查询电影讯息哦！\"信息的功能 2.完善注释信息 关于本地调试问题： 微信没有提供本地调试功能，给用户造成不小的麻烦。 打开Bottle的Debug功能，在本地运行自己的代码（启动Server），使用Chrome或Firefox上的Advanced Rest Client插件来模拟微信服务器向自己的应用发送请求， 这样就可以看到详细的报错信息，方便开发者定位修复问题，其相当于，自己的应用是SAE，而Advanced Rest Client模拟的是新微信客户端和微信服务器。 也有同学自己写脚本，模拟微信服务器发送数据，这也是同样的道理。 遗留问题： 1.从豆瓣拿到的海报图片都是竖向的，而微信中显示的是横向的，所以在微信看图片就被裁了一节，不过还好能看， 如何能完整显示海报图片，有待进一步research; 2.现在的通过电影名称返回的结果，实际上是拿的豆瓣返回的第一条数据，这样就有可能不准确，如何精确匹配用户的 查询条件，也还需要进一步研究。 \"\"\" @app.get ( \"/\" ) def checkSignature (): \"\"\" 这里是用来做接口验证的，从微信Server请求的URL中拿到\"signature\",\"timestamp\",\"nonce\"和\"echostr\"， 然后再将token, timestamp, nonce三个排序并进行Sha1计算，并将计算结果和拿到的signature进行比较， 如果相等，就说明验证通过。 话说微信的这个验证做的很渣，因为只要把echostr返回去，就能通过验证，这也就造成我看到一个Blog中， 验证那儿只返回了一个echostr，而纳闷了半天。 附微信Server请求的Url示例：http://yoursaeappid.sinaapp.com//?signature=730e3111ed7303fef52513c8733b431a0f933c7c &echostr=5853059253416844429&timestamp=1362713741&nonce=1362771581 \"\"\" token = \"\" # 你在微信公众平台上设置的TOKEN signature = request . GET . get ( 'signature' , None ) # 拼写不对害死人那，把signature写成singnature，直接导致怎么也认证不成功 timestamp = request . GET . get ( 'timestamp' , None ) nonce = request . GET . get ( 'nonce' , None ) echostr = request . GET . get ( 'echostr' , None ) tmpList = [ token , timestamp , nonce ] tmpList . sort () tmpstr = \" %s%s%s \" % tuple ( tmpList ) hashstr = hashlib . sha1 ( tmpstr ) . hexdigest () if hashstr == signature : return echostr else : return \"wws:indentify error\" def parse_msg (): \"\"\" 这里是用来解析微信Server Post过来的XML数据的，取出各字段对应的值，以备后面的代码调用，也可用lxml等模块。 \"\"\" recvmsg = request . body . read () # 严重卡壳的地方，最后还是在Stack OverFlow上找到了答案 root = ET . fromstring ( recvmsg ) msg = {} for child in root : msg [ child . tag ] = child . text return msg def query_movie_info (): \"\"\" 这里使用豆瓣的电影search API，通过关键字查询电影信息，这里的关键点是，一是关键字取XML中的Content值， 二是如果Content中存在汉字，就需要先转码，才能进行请求 \"\"\" movieurlbase = \"http://api.douban.com/v2/movie/search\" DOUBAN_APIKEY = \"\" # 这里需要填写你自己在豆瓣上申请的应用的APIKEY movieinfo = parse_msg () searchkeys = urllib2 . quote ( movieinfo [ \"Content\" ] . encode ( \"utf-8\" )) # 如果Content中存在汉字，就需要先转码，才能进行请求 url = ' %s ?q= %s &apikey= %s ' % ( movieurlbase , searchkeys , DOUBAN_APIKEY ) # return \"<p>{'url': %s}</p>\" % url # url = '%s%s?apikey=%s' % (movieurlbase, id[\"Content\"], DOUBAN_APIKEY) # resp = requests.get(url=url, headers=header) resp = urllib2 . urlopen ( url ) movie = json . loads ( resp . read ()) # return \"<p>{'movie': %s}</p>\" % movie # info = movie[\"subjects\"][0][\"title\"] + movie[\"subjects\"][0][\"alt\"] # info = movie['title'] + ': ' + ''.join(movie['summary']) return movie # return info def query_movie_details (): \"\"\" 这里使用豆瓣的电影subject API，通过在query_movie_info()中拿到的电影ID，来获取电影的summary。 \"\"\" movieurlbase = \"http://api.douban.com/v2/movie/subject/\" DOUBAN_APIKEY = \"\" # 这里需要填写你自己在豆瓣上申请的应用的APIKEY id = query_movie_info () url = ' %s%s ?apikey= %s ' % ( movieurlbase , id [ \"subjects\" ][ 0 ][ \"id\" ], DOUBAN_APIKEY ) resp = urllib2 . urlopen ( url ) description = json . loads ( resp . read ()) description = '' . join ( description [ 'summary' ]) return description @app.post ( \"/\" ) def response_msg (): \"\"\" 这里是响应微信Server的请求，并返回数据的主函数，判断Content内容，如果是\"Hello2BizUser\"，就 表明是一个新注册用户，调用纯文本格式返回，如果是其他的内容就组织数据以图文格式返回。 基本思路： # 拿到Post过来的数据 # 分析数据（拿到FromUserName、ToUserName、CreateTime、MsgType和content） # 构造回复信息（将你组织好的content返回给用户） \"\"\" #拿到并解析数据 msg = parse_msg () #设置返回数据模板 #纯文本格式 textTpl = \"\"\"<xml> <ToUserName><![CDATA[ %s ]]></ToUserName> <FromUserName><![CDATA[ %s ]]></FromUserName> <CreateTime> %s </CreateTime> <MsgType><![CDATA[ %s ]]></MsgType> <Content><![CDATA[ %s ]]></Content> <FuncFlag>0</FuncFlag> </xml>\"\"\" #图文格式 pictextTpl = \"\"\"<xml> <ToUserName><![CDATA[ %s ]]></ToUserName> <FromUserName><![CDATA[ %s ]]></FromUserName> <CreateTime> %s </CreateTime> <MsgType><![CDATA[news]]></MsgType> <ArticleCount>1</ArticleCount> <Articles> <item> <Title><![CDATA[ %s ]]></Title> <Description><![CDATA[ %s ]]></Description> <PicUrl><![CDATA[ %s ]]></PicUrl> <Url><![CDATA[ %s ]]></Url> </item> </Articles> <FuncFlag>1</FuncFlag> </xml> \"\"\" #判断Content内容，如果等于\"Hello2BizUser\"，表明是一个新关注用户，如果不是，就返回电影标题，电影简介 #和电影海报组成的图文信息 if msg [ \"Content\" ] == \"Hello2BizUser\" : echostr = textTpl % ( msg [ 'FromUserName' ], msg [ 'ToUserName' ], str ( int ( time . time ())), msg [ 'MsgType' ], u \"欢迎关注豆瓣电影，输入电影名称即可快速查询电影讯息哦！\" ) return echostr else : Content = query_movie_info () description = query_movie_details () echostr = pictextTpl % ( msg [ 'FromUserName' ], msg [ 'ToUserName' ], str ( int ( time . time ())), Content [ \"subjects\" ][ 0 ][ \"title\" ], description , Content [ \"subjects\" ][ 0 ][ \"images\" ][ \"large\" ], Content [ \"subjects\" ][ 0 ][ \"alt\" ]) return echostr if __name__ == \"__main__\" : # Interactive mode debug ( True ) run ( app , host = '127.0.0.1' , port = 8080 , reloader = True ) else : # Mod WSGI launch # import sae # debug(True) # os.chdir(os.path.dirname(__file__)) # app = default_app() # application = sae.create_wsgi_app(app) ################################################# #os.chdir(os.path.dirname(__file__))#Forbidden to access from bae.core.wsgi import WSGIApplication application = WSGIApplication ( app ) 注：代码中用json.dumps会更好。 后注：此注不对。 深入阶段，将http:// www.cnblogs.com/mchina/tag/%E5% BE % AE %E4% BF %A1%E5%85% AC %E4% BC %97/里的功能用python实现之 。 …… 本代码需要与bottle.py一并上传到服务器空间。 附上一些特别信息： 微信开发调试小工具下载： http://www.cnblogs.com/linkbiz/archive/2013/05/16/3080306.html 本人微信公众号pythonwoodpub， 开发项目澳洲红酒微信服务号，","title":"微信公众平台开发（免费云BAE+高效优雅的Python+网站开放的API）","url":"2013/10/微信公众平台开发（免费云BAE+高效优雅的Python+网站开放的API）/","tags":"技术"},{"text":"第一次独立完成的C++小项目，40小时 + 5小时Update + 8小时Linux移植。 过程： 过程非常认真，一个星期主要就是忙这个，为了完成某个部分，有时饭都推迟吃，连续对着电脑10几个小时很累，晚上写到很晚才睡，休息也不够，这让我明白到程序员是不好当的！ 成果： 最终版在Win7+ VS2005 、Ubuntu+G++环境都成功。 环境工具的选择： VS2010随便写个程序在XP原生态下都不能运行！VC6太旧，XP下用得好。VS2008是Vista时代的魂魄。所以最好还是用VS2005。下载地址：Visual Studio 各版本下载合集vs2005下载vs2008下载vs2010下载vs2012下载 得益： 一开始将main分成四个独立子函数，用的是增量式开发，俗称打桩，用得比较好，好处是模块化。这一点非常有益。 记得刚开始学C语言的第21天，几天里，20个小时写出个蹩脚的图书馆综合系统。得益于这个经验，才令我相信我能完成。 《Accelerate C++》的确是非常适合学习C++的，以前看了不明白它的好，认真看才知妙！完全借用了它的字符图形函数处理类Picture。 改进： 要善用sprintf和sscanf：atoi、atof、itoa、itow函数是windows平台下实现字符串与数值相互转换的函数。Linux平台下请使用标准库中的sprintf与sscanf函数。 调试过程很大部分是在UI用户中，说明UI函数多，且易错。 房号设计02 - 23 ，0223 ，整数怎样表示，这些问题一直缠绕，一开始没解决好，就会影响全局。 备忘： 类的定义和实现在项目推进过程中不断修改，逐渐完善。 用户交互模块最大，ui()函数的ui.cpp文件有454行， 14KB 。有的模块文件只有几十行，这些开始时是没想到的。 什么是优雅，注重代码重用，函数最好小而精，一次只做一件事。也是Unix类系统的神髓。 老师对我的实验成果~~相当~~比较满意，给分也~~相对地~~高一点。感谢。","title":"大二C++课程期末作业——一个小工程项目总结","url":"2013/07/大二C++课程期末作业——一个小工程项目总结/","tags":"技术"},{"text":"记录大二下学期转换ubuntu10.04的一些系统折腾 版本选择： 经多次实验，Ubuntu个人认为长期支持（ LTS ）版才值得装。 VMware9中测试：Ubuntu10.04开机内存170M，Ubuntu12.04开机内存340M。 个人感觉Ubuntu12.04像win7华丽消耗大，Ubuntu10.04像XP，对程序员实在。 Ubuntu12.04的桌面切换真麻烦。 我最后选择了VMware9+Ubuntu10.04。 安装Linux-Ubuntu（VMware平台支持下）： 双系统形式： wubi安装：不用分区，直接在某原分区建立文件来代表Ubuntu，应该是虚拟化技术。安全快捷，易卸载。 光盘安装：win7原来有4分区，安装Ubuntu后E盘少了7G，无其它变化，推测装在了E盘。 单系统： 安装后占3.6G左右，其中用于虚拟内存交换的空间2G，系统文件/bin/*等只占1G多。 安装过程的技巧： 安装过程所增加的用户只是桌面用户，非超级用户。安装后用sudo root passwd修改root密码。 计算机名和用户名最好3到6个字符就好了。 Ubuntu安装过程下载中文语言包时最好跳过，太慢了，装好后自己设置一个快的源，然后下载。 常用软件安装： 极点五笔，个人比较钟意。 Adobe Flash 为了网页（若安装gecko_mediaplayer，则不用）。 Mplayer 相传宇宙最强播放器（然后最好gecko_mediaplayer，SMPlayer一起装）。 wine 用于运行Windows程序。 aMule 电骡（官方中译），可选，个人测试不好。 build-essential 程序依赖库。 g++,nasm,emacs,open-ssh,vnc…… gvim 就我而言，我更喜欢gvim，即使用了3个月emacs了，但是还是义无反顾地转成vim党了。 gvim是编辑器之神，emacs是神一样的编辑器。前句强调gvim始终是一个编辑器，后句说明emacs可以做远超编辑器的事。 使用－习惯： Ubuntu12.04开机都会打开终端（Terminal）,在第二桌面。比较喜欢linux的多虚拟桌面功能。 firefox总是在第三桌面打开，影音在第四桌面。 将常打开的程序放在面板上。 终端： 输入密码不以星号表示，无显示，惯了就好。桌面窗口环境则由星号表示。 最常用的键：Tab；方向上；Ctrl+C； 补全，重复历史，强制终止。 最常用命令：ls；cat；history ； 最好用的符号：|；<；>； Ctrl＋A/D/L/R： 到行首/行尾/清屏/查找命令历史 Win7/Linux字符编码问题： Win7/Linux编码差异： win7的多字符实现： GBK ，2字节；Unicode：unicode16，2字节。Linux的多字符实现：utf8，1-6字节；Unicode：unicode32，4字节。 换行符问题： win7换行＝\\r\\n 而Linux换行＝\\n；所以Linux文本在win7下用记事本打开都是一行的。转换很简单用fromdos / todos 命令就行。 win7下保存的文本文件复制到Linux下后，中文变成乱码。 ＝＝＝〉win7的字符是GBK，Linux的字符是UTF8，utf8在win7可以正常显示，所以建议用iconv命令转成UTF8，而不是将Linux默认的编码变成GBK来适应。 win7下保存的文本文件到Linux下后，双击提示运行。 ＝＝＝〉方法：chmod a-x ；或者先在win7打包成zip文件，再复制，再解压，就可以彻底解决。这是个目前最好的通用方法。 感受 至今已经输入2000个命令。不知不觉习惯中。 * | more # 分屏显示 iconv -f gbk -t utf8 sample_config.txt | fromdos > ../release/sample_config cat -n ~/.bash_history | todos > _bash_history2013-07-10.txt JNU 2013-07-10 16:41:51 今天考完《Linux/Unix使用》。","title":"虚拟机系统正式转换——从windows到Linux-ubuntu新手","url":"2013/07/虚拟机系统正式转换——从windows到Linux-ubuntu新手/","tags":"技术"},{"text":"笔迹之始 我大学开始时是个商科，或者说文科的学生。非计算机系的，仅会计算机。 后自学多门计算机语言，越觉编程之高明，神奇。 如今的世界，是技术革命的世界，如今的中国，是互联网带头的民主，如今的社会，是正在电子虚拟化的社会，正如《黑客帝国》。 我亲历大学，觉大学学术之流甚少，同学进取之心微微。 然而，举头望明月，我爸非李刚。甚惑，曾迷，思而不得。 何以自强？我常常自问。 技术。顿觉当时\"师夷长技\"之风高啊！ 理性的头脑，只能接受逻辑思维的单神经细胞，这正好叫因地制宜。 于是，大学一学期之后，从2012年初始，奋身地转向技术领域，至今1年7个月了。 选择这里开博是因为搜索到的好文章，算这里最多。CSDN杂而不精，百度空间，开源中国，网易，新浪，平平无奇。 博客究竟为什么？为了有共同爱好的你，朋友，兄弟也好。 总之专注于技术的每一人都是我写博客时脑海中的读者。 自学所获： 1、熟悉C/C++,Linux桌面。java,汇编一般。 2、精通Visual Studio C++，犹以VC6突出。 3、对操作系统的实现一知半解，曾用NASM+C模仿编写系统，后中断。 4、会使用G++， GCC ，make，vim，等Linux下的工具编程。 5、略懂HTML、 CSS 、 JAVASCRIPT 、JSP等网页相关。 未来方向： 1、移动平台 2、Linux 3、C++ 2013-07-06 18:22:37 暨南大学 后天开始期末考了。","title":"笔迹之始","url":"2013/07/笔迹之始/","tags":"技术"}]}